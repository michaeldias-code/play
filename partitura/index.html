<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Profissional de Partituras</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            color: #333;
        }
        
        /* Layout Principal */
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar de Ferramentas */
        .sidebar {
            width: 280px;
            background: #ffffff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        /* √Årea Principal */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #f8f9fa;
        }

        /* Barra Superior */
        .top-bar {
            background: white;
            padding: 10px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-title h1 {
            font-size: 18px;
            color: #1a73e8;
        }

        /* Se√ß√µes da Sidebar */
        .sidebar-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            color: #70757a;
            letter-spacing: 0.8px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        /* Grupos de Bot√µes */
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
        }

        .button-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Estilo dos Bot√µes */
        button, .file-upload-label {
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #3c4043;
        }

        button:hover {
            background: #f1f3f4;
            border-color: #bdc1c6;
        }

        button.selected {
            background: #e8f0fe;
            color: #1a73e8;
            border-color: #1a73e8;
        }

        button.active {
            background: #e6f4ea;
            color: #1e8e3e;
            border-color: #1e8e3e;
        }

        /* Bot√µes de A√ß√£o Espec√≠ficos */
        .btn-primary { background: #1a73e8; color: white; border: none; }
        .btn-primary:hover { background: #1557b0; }
        
        .btn-success { background: #1e8e3e; color: white; border: none; }
        .btn-success:hover { background: #137333; }

        .btn-danger { background: #d93025; color: white; border: none; }
        .btn-danger:hover { background: #a50e0e; }

        .btn-warning { background: #f9ab00; color: white; border: none; }
        .btn-warning:hover { background: #ea8600; }

        /* Importa√ß√£o de √Åudio (Discreta) */
        .audio-import-compact {
            margin: 15px 20px 0;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        .audio-import-compact summary {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            color: #5f6368;
            background: #f8f9fa;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .audio-import-compact summary:hover {
            background: #f1f3f4;
        }

        .audio-import-content {
            padding: 15px;
            border-top: 1px solid #eee;
        }

        /* √Årea de Score */
        .score-viewport {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: block; /* Mudado de flex para block para melhor scroll horizontal */
            text-align: center; /* Centraliza o conte√∫do se for menor que a tela */
        }

        .score-paper {
            display: inline-block; /* Permite centraliza√ß√£o via text-align do pai */
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-radius: 4px;
            min-width: fit-content;
            margin: 0 auto;
            text-align: left; /* Reseta o alinhamento de texto para o canvas */
        }

        /* Metadados (Top Bar) */
        .meta-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .meta-inputs input {
            padding: 6px 10px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 13px;
        }

        .meta-inputs label {
            font-size: 12px;
            font-weight: 600;
            color: #5f6368;
        }

        /* Utilit√°rios */
        .flex-row { display: flex; gap: 8px; align-items: center; }
        .flex-grow { flex: 1; }
        .mobile-only { display: none; }

        /* Estilos originais preservados/adaptados */
        .upload-area {
            border: 2px dashed #1a73e8;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background: #f8f9ff;
            margin-bottom: 10px;
        }
        .upload-area.has-file { border-color: #1e8e3e; background: #f0fff4; }
        .upload-icon { font-size: 24px; margin-bottom: 5px; }
        
        .progress { margin-top: 10px; }
        .progress-bar { height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: #1a73e8; width: 0%; transition: width 0.3s; }

        .settings { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px; }
        .setting-group label { display: block; font-size: 12px; margin-bottom: 4px; font-weight: 600; }
        .settings select { width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #dadce0; }

        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }
        .modal-content { background: white; padding: 25px; border-radius: 8px; width: 400px; max-width: 90vw; }
        .modal-buttons { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }

        #staff-indicator { font-size: 12px; font-weight: bold; color: #1a73e8; }

        @media (max-width: 768px) {
            .app-container { flex-direction: column; height: 100vh; }
            .sidebar { 
                width: 100%; 
                height: auto; 
                max-height: 180px;
                border-right: none; 
                border-bottom: 1px solid #e0e0e0; 
                padding: 10px;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                white-space: nowrap;
                gap: 15px;
                display: flex;
            }
            .sidebar-section {
                min-width: auto;
                flex-shrink: 0;
            }
            .sidebar-section h3 {
                font-size: 9px;
                margin-bottom: 5px;
            }
            .button-list {
                flex-direction: row;
                gap: 5px;
            }
            .button-grid {
                display: flex;
                flex-direction: row;
                gap: 5px;
            }
            .top-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 10px;
                gap: 12px;
                height: auto;
                overflow-y: visible;
            }
            .meta-inputs {
                flex-direction: column;
                gap: 8px;
                background: #f8f9fa;
                padding: 12px;
                border-radius: 8px;
                border: 1px solid #e0e0e0;
            }
            .meta-inputs .flex-row {
                justify-content: flex-start;
                width: 100%;
                gap: 10px;
            }
            .meta-inputs label {
                width: 30px;
                text-align: center;
                flex-shrink: 0;
            }
            .meta-inputs input {
                flex: 1;
                width: auto !important;
                min-width: 0;
            }
            .header-title {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 5px;
            }
            .header-title h1 {
                font-size: 18px;
                margin: 0;
            }
            .mobile-only { display: inline-block; }
            /* Esconder texto longo nos bot√µes em telas pequenas */
            .btn-text { display: none; }
            
            button, .file-upload-label {
                padding: 8px;
                min-width: 40px;
                width: auto !important;
                justify-content: center;
                display: inline-flex;
                align-items: center;
                margin: 0 !important;
            }
            
            .score-viewport {
                flex: 1;
                overflow: auto;
            }
            .audio-import-content > div {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            .settings {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            .audio-import-compact {
                margin: 10px 10px 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar: Ferramentas de Edi√ß√£o -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <h3>Modo de Edi√ß√£o</h3>
                <div class="button-list">
                    <button id="note-mode-btn" class="selected">üéµ <span class="btn-text">Melodia</span></button>
                    <button id="rest-mode-btn">ùÑΩ <span class="btn-text">Pausa</span></button>
                    <button id="harmony-btn">üéπ <span class="btn-text">Harmonia</span></button>
                    <div class="flex-row" style="margin-top: 5px;">
                        <button id="play-btn" class="btn-primary flex-grow" title="Tocar Partitura (Atalho: Espa√ßo)">‚ñ∂ <span class="btn-text">Tocar</span></button>
                        <button id="undo-btn" class="btn-warning" title="Desfazer (Atalho: Ctrl+Z)">‚Ü∂</button>
                        <button id="clear-btn" class="btn-danger" title="Limpar Tudo">‚úï</button>
                    </div>
                    <button id="how-to-edit-btn" style="margin-top: 8px; width: 100%; background: #e8f0fe; color: #1a73e8; border-color: #1a73e8; font-weight: bold;">üìù <span class="btn-text">Ajuda</span></button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>Acidentes</h3>
                <div class="button-grid">
                    <button class="accidental-btn" data-accidental="sharp" title="Sustenido">‚ôØ</button>
                    <button class="accidental-btn" data-accidental="flat" title="Bemol">‚ô≠</button>
                    <button class="accidental-btn" data-accidental="natural" title="Bequadro">‚ôÆ</button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>Armadura</h3>
                <div class="button-grid">
                    <button id="key-sharp-up" title="Mais Sustenidos">‚ôØ+</button>
                    <button id="key-sharp-down" title="Menos Sustenidos">‚ôØ-</button>
                    <button id="key-flat-up" title="Mais Bem√≥is">‚ô≠+</button>
                    <button id="key-flat-down" title="Menos Bem√≥is">‚ô≠-</button>
                    <button id="key-reset" title="Resetar">‚ü≤</button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>Estrutura</h3>
                <div class="button-list">
                    <button id="add-system-btn">‚ûï <span class="btn-text">Sistema</span></button>
                    <button id="add-staff-btn">‚ûï <span class="btn-text">Pauta</span></button>
                    <button id="finish-edit-btn" class="btn-success">‚úÖ <span class="btn-text">Finalizar</span></button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>Arquivos</h3>
                <div class="button-list">
                    <label for="import-file" class="file-upload-label" style="width: 100%; border-color: #dadce0;">üì• <span class="btn-text">Abrir</span></label>
                    <input type="file" id="import-file" accept=".json" style="display: none;">
                    <button id="download-btn" class="btn-primary">üíæ <span class="btn-text">Exportar</span></button>
                </div>
            </div>

            <div style="margin-top: auto; padding-top: 20px; font-size: 11px; color: #9aa0a6; text-align: center;">
                Pressione Ctrl + S para salvar
            </div>
        </aside>

        <!-- √Årea Principal -->
        <main class="main-content">
            <!-- Barra Superior: Metadados -->
            <header class="top-bar">
                <div class="header-title">
                    <h1>üéµ Partitura</h1>
                    <span id="staff-indicator">Sistema 1/4</span>
                </div>
                
                <div class="meta-inputs">
                    <div class="flex-row">
                        <label title="T√≠tulo"><span class="btn-text">T√≠tulo:</span><span class="mobile-only">üè∑Ô∏è</span></label>
                        <input type="text" id="title-input" placeholder="T√≠tulo" value="Minha Composi√ß√£o" style="width: 180px;">
                    </div>
                    <div class="flex-row">
                        <label title="Autor"><span class="btn-text">Autor:</span><span class="mobile-only">üë§</span></label>
                        <input type="text" id="composer-input" placeholder="Compositor" style="width: 140px;">
                    </div>
                    <div class="flex-row">
                        <label title="F√≥rmula"><span class="btn-text">F√≥rmula:</span><span class="mobile-only">‚è±Ô∏è</span></label>
                        <input type="number" id="time-top" min="1" max="16" value="4" style="width: 45px;">
                        <span>/</span>
                        <input type="number" id="time-bottom" min="1" max="16" value="4" style="width: 45px;">
                    </div>
                    <div class="flex-row">
                        <label title="BPM"><span class="btn-text">BPM:</span><span class="mobile-only">‚è≤Ô∏è</span></label>
                        <input type="number" id="tempo-input" min="40" max="240" value="120" style="width: 60px;">
                    </div>
                </div>
            </header>

            <!-- Importa√ß√£o de √Åudio: Discreta -->
            <details class="audio-import-compact">
                <summary>üéµ Ferramentas de Importa√ß√£o de √Åudio (Extra)</summary>
                <div class="audio-import-content">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <div class="upload-area" id="uploadArea">
                                <div class="upload-icon">üìÅ</div>
                                <p><strong>Clique ou arraste</strong> o √°udio aqui</p>
                                <input type="file" id="audioFile" accept="audio/*" style="display: none;">
                            </div>
                            <div id="audioInfo" class="audio-info" style="margin-top: 10px; padding: 8px; font-size: 12px; background: #f8f9fa; border: 1px solid #eee; border-radius: 4px; display: none;"></div>
                        </div>
                        
                        <div>
                            <div class="settings" style="margin-bottom: 10px;">
                                <div class="setting-group">
                                    <label>Autotune: <span id="strengthValue">80%</span></label>
                                    <input type="range" id="strength" min="0" max="100" value="80" style="width: 100%;">
                                </div>
                                <div class="setting-group">
                                    <label>Escala Musical</label>
                                    <select id="scale">
                                        <option value="chromatic">Crom√°tica</option>
                                        <option value="major">Maior</option>
                                        <option value="minor">Menor</option>
                                        <option value="pentatonic">Pentat√¥nica</option>
                                    </select>
                                </div>
                            </div>
                            
                            <button class="btn-process btn-primary" id="processBtn" disabled style="width: 100%; padding: 12px;">
                                üöÄ Processar e Importar Notas
                            </button>
                            
                            <div class="progress" id="progress" style="display: none;">
                                <p id="progressText" style="font-size: 11px; margin-bottom: 5px;">Processando...</p>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="errorMessage" class="error-message" style="margin-top: 10px; font-size: 12px; color: #d93025;"></div>
                </div>
            </details>

            <!-- Visualizador da Partitura -->
            <div class="score-viewport">
                <div class="score-paper">
                    <canvas id="score"></canvas>
                </div>
            </div>
            
            <footer style="padding: 10px; text-align: center; font-size: 12px; color: #70757a; background: white; border-top: 1px solid #e0e0e0;">
                Dica: Clique com o bot√£o direito para diminuir a dura√ß√£o da nota. Use as setas para navegar entre as pautas.
            </footer>
        </main>
    </div>
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <h2>Exportar Partitura</h2>
            <p style="margin-bottom: 15px; font-size: 14px;">Escolha o formato:</p>
            <div class="modal-buttons">
                <button id="export-json">üìÑ JSON</button>
                <button id="export-musicxml">üéº MusicXML</button>
                <button id="export-pdf">üñºÔ∏è PNG</button>
                <button id="export-cancel" style="background: #ccc;">Cancelar</button>
            </div>
        </div>
    </div>
    <div id="help-modal" class="modal">
        <div class="modal-content" style="width: 500px; max-width: 90vw; max-height: 80vh; overflow-y: auto;">
            <h2 style="margin-bottom: 15px; color: #1a73e8;">Como usar o Editor</h2>
            <div style="font-size: 14px; line-height: 1.6; color: #3c4043;">
                <p><strong>üöÄ Workflow Sugerido:</strong> Inicie pela melodia (parcial ou completa) e adicione a harmonia depois. Isso garante maior organiza√ß√£o visual e estrutural da sua m√∫sica.</p>
                
                <p style="margin-top: 10px;"><strong>‚è±Ô∏è Valores de Notas e Pausas:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Clique com o <strong>bot√£o esquerdo</strong> em uma nota/pausa j√° inserida para <strong>aumentar</strong> seu valor.</li>
                    <li>Clique com o <strong>bot√£o direito</strong> para <strong>diminuir</strong> seu valor.</li>
                </ul>

                <p style="margin-top: 10px;"><strong>‚úÖ Finalizar Edi√ß√£o:</strong> Este bot√£o √© fundamental! Ele organiza todas as notas que voc√™ inseriu livremente, alinhando-as e criando as <strong>linhas de compasso</strong> automaticamente com base na f√≥rmula de compasso escolhida.</p>

                <p style="margin-top: 10px;"><strong>üéπ Harmonia:</strong> Ative este modo para sobrepor notas na mesma posi√ß√£o horizontal, criando acordes.</p>

                <p style="margin-top: 10px;"><strong>‚ôØ/‚ô≠ Acidentes:</strong> Selecione o acidente antes de clicar na pauta. Ele ser√° aplicado √† pr√≥xima nota que voc√™ inserir.</p>

                <p style="margin-top: 10px;"><strong>üìÇ Arquivos:</strong> Use "Exportar" para salvar seu trabalho em JSON (para editar depois), PNG ou MusicXML.</p>

                <p style="margin-top: 10px;"><strong>‚ûï Estrutura:</strong> Use "Novo Sistema" para criar uma nova linha de pautas (quebra de linha) e "Nova Pauta" para adicionar mais um instrumento/linha ao sistema atual.</p>
            </div>
            <div class="modal-buttons" style="margin-top: 20px;">
                <button id="help-close" class="btn-primary" style="width: 100%;">Entendi!</button>
            </div>
        </div>
    </div>
<script>
// Editor de Partituras - Sistema de Pautas Autom√°ticas
let staffs = Array.from({ length: 4 }, (_, i) => ({
    id: Date.now() + i,
    staves: [
        { clef: 'treble', notes: [], label: i === 0 ? 'P1' : '' },
        { clef: 'bass', notes: [], label: '' }
    ]
}));
let currentSystemIndex = 0;
let currentStaffIndex = 0; // Index da pauta dentro do sistema
let currentClef = 'treble';
let isNoteMode = true;
let isEditing = true;
const durationSequence = [
    { type: 'semicolcheia', dot: false },
    { type: 'semicolcheia', dot: true },
    { type: 'colcheia', dot: false },
    { type: 'colcheia', dot: true },
    { type: 'seminima', dot: false },
    { type: 'seminima', dot: true },
    { type: 'minima', dot: false },
    { type: 'minima', dot: true },
    { type: 'semibreve', dot: false },
    { type: 'semibreve', dot: true }
];
let selectedAccidental = null;
let isHarmonyMode = false;
let undoStack = [];
let keySharps = 0;
let keyFlats = 0;
let timeSignature = { top: 4, bottom: 4 };
let tempo = 120;

// Vari√°veis para processamento de √°udio
let audioBuffer = null;
let processedBuffer = null;
let audioContext = null;
let musicalNotes = []; // Array para armazenar notas musicais ao longo do tempo
let currentNoteData = null; // Dados da nota atual sendo coletada
let lastNoteStartTime = 0;
let noteChangeBuffer = []; // Buffer para confirmar mudan√ßa de nota
let lastStablePitch = null; // √öltimo pitch est√°vel detectado
const canvas = document.getElementById("score");
const ctx = canvas.getContext("2d");

const SPACING = 50;
const MIN_SCORE_WIDTH = window.innerWidth < 768 ? 600 : 900;
let CLEF_MARGIN = 130;
let timeSignatureX = 110; // Posi√ß√£o horizontal do compasso (4/4)
const SYSTEM_SPACING = 400; // Espa√ßamento entre sistemas
const STAFF_HEIGHT = 80;    // Altura das 5 linhas
const STAFF_GAP = 100;      // Espa√ßo entre pautas de um mesmo sistema
const MAX_BEATS_PER_SYSTEM = 16; // M√°ximo de batidas antes de quebrar sistema

const noteYTreble = {
    "C6": -40, "B5": -30, "A5": -20, "G5": -10, "F5": 0, "E5": 10,
    "D5": 20, "C5": 30, "B4": 40, "A4": 50, "G4": 60,
    "F4": 70, "E4": 80, "D4": 90, "C4": 100, "B3": 110,
    "A3": 120, "G3": 130, "F3": 140, "E3": 150, "D3": 160, "C3": 170, "B2": 180
};
const noteYBass = {
    "E4": -40, "D4": -30, "C4": -20, "B3": -10, "A3": 0, "G3": 10,
    "F3": 20, "E3": 30, "D3": 40, "C3": 50, "B2": 60, "A2": 70,
    "G2": 80, "F2": 90, "E2": 100, "D2": 110, "C2": 120, "B1": 130, "A1": 140, "G1": 150, "F1": 160, "E1": 170, "D1": 180
};
const freqs = {
    "A0": 27.50, "B0": 30.87, "C1": 32.70, "D1": 36.71, "E1": 41.20, "F1": 43.65, "G1": 49.00,
    "A1": 55.00, "B1": 61.74, "C2": 65.41, "D2": 73.42, "E2": 82.41, "F2": 87.31, "G2": 98.00,
    "A2": 110.00, "B2": 123.47, "C3": 130.81, "D3": 146.83, "E3": 164.81, "F3": 174.61, "G3": 196.00,
    "A3": 220.00, "B3": 246.94, "C4": 261.63, "D4": 293.66, "E4": 329.63, "F4": 349.23, "G4": 392.00,
    "A4": 440.00, "B4": 493.88, "C5": 523.25, "D5": 587.33, "E5": 659.25,
    "F5": 698.46, "G5": 783.99, "A5": 880.00, "B5": 987.77, "C6": 1046.50
};
const noteDurations = {
    "semibreve": 2.0, "minima": 1.0, "seminima": 0.5, "colcheia": 0.25, "semicolcheia": 0.125,
    "pausa-semibreve": 2.0, "pausa-minima": 1.0, "pausa-seminima": 0.5, 
    "pausa-colcheia": 0.25, "pausa-semicolcheia": 0.125
};
const SHARP_FACTOR = 1.059463;
const FLAT_FACTOR = 1 / SHARP_FACTOR;

// Escalas musicais (semitons relativos a C)
const scales = {
    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    major: [0, 2, 4, 5, 7, 9, 11],
    minor: [0, 2, 3, 5, 7, 8, 10],
    pentatonic: [0, 2, 4, 7, 9]
};
function calculateSystemBeats(system) {
    let maxBeats = 0;
    system.staves.forEach(staff => {
        let beats = 0;
        staff.notes.forEach(chord => {
            beats += getDurationInBeats(chord[0].type, chord[0].dot, timeSignature.bottom);
        });
        if (beats > maxBeats) maxBeats = beats;
    });
    return maxBeats;
}

function checkAndCreateNewStaff() {
    const currentSystem = staffs[currentSystemIndex];
    const totalBeats = calculateSystemBeats(currentSystem);
    
    if (totalBeats >= MAX_BEATS_PER_SYSTEM) {
        // Criar novo sistema com o mesmo layout do anterior
        const newStaves = currentSystem.staves.map(s => ({
            clef: s.clef,
            notes: [],
            label: ''
        }));
        staffs.push({
            id: Date.now(),
            staves: newStaves
        });
        currentSystemIndex = staffs.length - 1;
        updateStaffIndicator();
        return true;
    }
    return false;
}

function updateStaffIndicator() {
    const indicator = document.getElementById('staff-indicator');
    if (indicator) {
        indicator.textContent = `Sistema ${currentSystemIndex + 1}/${staffs.length}`;
    }
}

// Converte tempo em segundos para tipo de nota musical com l√≥gica matem√°tica
function calculateNoteType(seconds, bpm = 30) {
    // BPM = batidas por minuto
    // Uma batida = 60/BPM segundos para colcheia (quarter note)
    const quarterNoteDuration = 60 / bpm; // dura√ß√£o de uma colcheia em segundos

    // Calcular quantas colcheias cabem no tempo
    const quarterNotes = seconds / quarterNoteDuration;

    // L√≥gica matem√°tica: usar pot√™ncias de 2 para dura√ß√µes
    // minima (4 colcheias), seminima (2 colcheias), colcheia (1 colcheia)
    if (quarterNotes >= 3.5) return 'minima';      // >= 3.5 colcheias = minima
    if (quarterNotes >= 1.5) return 'seminima';    // >= 1.5 colcheias = seminima
    return 'colcheia';                             // < 1.5 colcheias = colcheia
}

function hideError() {
    const errorMessage = document.getElementById('errorMessage');
    errorMessage.style.display = 'none';
}

function showError(message) {
    const errorMessage = document.getElementById('errorMessage');
    errorMessage.textContent = '‚ùå ' + message;
    errorMessage.style.display = 'block';

    // Sugest√µes baseadas no erro
    if (message.includes('n√£o suportado')) {
        errorMessage.innerHTML += '<br><br><strong>Solu√ß√£o:</strong> Converta o arquivo para WAV ou MP3 usando um app como:<br>‚Ä¢ <a href="https://online-audio-converter.com" target="_blank" style="color: #c53030;">Online Audio Converter</a><br>‚Ä¢ Media Converter (Android)<br>‚Ä¢ The Audio Converter (iOS)';
    }
}

function showAudioInfo(buffer, file) {
    const audioInfo = document.getElementById('audioInfo');
    const duration = buffer.duration.toFixed(1);
    const sampleRate = buffer.sampleRate;
    const channels = buffer.numberOfChannels;
    const fileSize = (file.size / 1024 / 1024).toFixed(2);

    audioInfo.innerHTML = `
        <strong>Informa√ß√µes do √°udio:</strong><br>
        Dura√ß√£o: ${duration}s | Taxa: ${sampleRate}Hz | Canais: ${channels} | Tamanho: ${fileSize}MB
    `;
    audioInfo.style.display = 'block';
}

function getNoteName(freq) {
    const A4 = 440;
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    const halfSteps = 12 * Math.log2(freq / A4) + 69; // 69 semitons = A4 (correto)
    const octave = Math.floor(halfSteps / 12);
    const note = Math.round(halfSteps % 12);

    return noteNames[note] + octave;
}

function closestNoteInScale(freq, scale) {
    const A4 = 440;
    const C0 = A4 * Math.pow(2, -4.75); // C0 frequency

    // Converter frequ√™ncia para semitons de C0
    const halfSteps = 12 * Math.log2(freq / C0);
    const octave = Math.floor(halfSteps / 12);
    const noteInOctave = Math.round(halfSteps % 12);

    // Encontrar nota mais pr√≥xima na escala
    let closest = scale[0];
    let minDist = Math.abs(noteInOctave - scale[0]);

    for (let note of scale) {
        const dist = Math.abs(noteInOctave - note);
        if (dist < minDist) {
            minDist = dist;
            closest = note;
        }
    }

    // Converter de volta para frequ√™ncia
    const targetHalfSteps = octave * 12 + closest;
    return C0 * Math.pow(2, targetHalfSteps / 12);
}

function phaseVocoder(buffer, ratio, fftSize) {
    // Implementa√ß√£o simplificada de phase vocoder
    // Para produ√ß√£o seria ideal usar FFT, mas aqui uso interpola√ß√£o de alta qualidade
    const output = new Float32Array(buffer.length);

    for (let i = 0; i < output.length; i++) {
        const sourcePos = i / ratio;

        // Interpola√ß√£o c√∫bica (melhor que linear)
        const i0 = Math.floor(sourcePos) - 1;
        const i1 = Math.floor(sourcePos);
        const i2 = Math.floor(sourcePos) + 1;
        const i3 = Math.floor(sourcePos) + 2;
        const frac = sourcePos - Math.floor(sourcePos);

        // Garantir limites
        const s0 = (i0 >= 0 && i0 < buffer.length) ? buffer[i0] : 0;
        const s1 = (i1 >= 0 && i1 < buffer.length) ? buffer[i1] : 0;
        const s2 = (i2 >= 0 && i2 < buffer.length) ? buffer[i2] : 0;
        const s3 = (i3 >= 0 && i3 < buffer.length) ? buffer[i3] : 0;

        // Interpola√ß√£o c√∫bica de Catmull-Rom
        const a0 = -0.5 * s0 + 1.5 * s1 - 1.5 * s2 + 0.5 * s3;
        const a1 = s0 - 2.5 * s1 + 2 * s2 - 0.5 * s3;
        const a2 = -0.5 * s0 + 0.5 * s2;
        const a3 = s1;

        output[i] = a0 * frac * frac * frac + a1 * frac * frac + a2 * frac + a3;
    }

    return output;
}

function detectPitch(buffer, sampleRate) {
    const SIZE = buffer.length;
    let rms = 0;

    // Calcular RMS
    for (let i = 0; i < SIZE; i++) {
        rms += buffer[i] * buffer[i];
    }
    rms = Math.sqrt(rms / SIZE);

    if (rms < 0.005) return -1; // Sil√™ncio

    // Autocorrela√ß√£o usando YIN algorithm (mais preciso)
    const threshold = 0.1;
    const minLag = Math.floor(sampleRate / 1000); // 1000 Hz max
    const maxLag = Math.floor(sampleRate / 80);   // 80 Hz min

    // Difference function
    const diff = new Float32Array(maxLag);
    for (let lag = 0; lag < maxLag; lag++) {
        let sum = 0;
        for (let i = 0; i < SIZE - maxLag; i++) {
            const delta = buffer[i] - buffer[i + lag];
            sum += delta * delta;
        }
        diff[lag] = sum;
    }

    // Cumulative mean normalized difference
    const cmndf = new Float32Array(maxLag);
    cmndf[0] = 1;
    let runningSum = 0;

    for (let lag = 1; lag < maxLag; lag++) {
        runningSum += diff[lag];
        cmndf[lag] = diff[lag] / (runningSum / lag);
    }

    // Find first minimum below threshold
    let bestLag = -1;
    for (let lag = minLag; lag < maxLag; lag++) {
        if (cmndf[lag] < threshold) {
            // Parabolic interpolation for sub-sample accuracy
            if (lag > 0 && lag < maxLag - 1) {
                const s0 = cmndf[lag - 1];
                const s1 = cmndf[lag];
                const s2 = cmndf[lag + 1];
                const adjustment = (s2 - s0) / (2 * (2 * s1 - s2 - s0));
                bestLag = lag + adjustment;
            } else {
                bestLag = lag;
            }
            break;
        }
    }

    if (bestLag > 0) {
        const pitch = sampleRate / bestLag;
        if (pitch >= 80 && pitch <= 1000) {
            return pitch;
        }
    }

    return -1;
}

function updateProgress(percent, text) {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    progressFill.style.width = percent + '%';
    if (text) progressText.textContent = text;
}

function bufferToWave(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;

    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;

    const data = [];
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
            let sample = buffer.getChannelData(ch)[i];
            sample = Math.max(-1, Math.min(1, sample));
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            data.push(sample);
        }
    }

    const dataSize = data.length * bytesPerSample;
    const view = new DataView(new ArrayBuffer(44 + dataSize));

    // RIFF header
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');

    // fmt chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);

    // data chunk
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i = 0; i < data.length; i++) {
        view.setInt16(offset, data[i], true);
        offset += 2;
    }

    return view.buffer;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

async function handleFileSelect() {
    const fileInput = document.getElementById('audioFile');
    const uploadArea = document.getElementById('uploadArea');
    const processBtn = document.getElementById('processBtn');
    const file = fileInput.files[0];
    if (!file) return;

    hideError();
    document.getElementById('audioInfo').style.display = 'none';
    uploadArea.classList.remove('has-file', 'error');
    processBtn.disabled = true;

    // Mostrar que est√° carregando
    uploadArea.querySelector('p').innerHTML = `<strong>‚è≥ Carregando ${file.name}...</strong>`;

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Tentar carregar o √°udio
        const arrayBuffer = await file.arrayBuffer();

        // Tentar decodificar
        try {
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // Sucesso!
            uploadArea.classList.add('has-file');
            uploadArea.querySelector('p').innerHTML = `<strong>‚úì ${file.name}</strong><br><span style="font-size: 12px;">Pronto para processar</span>`;
            processBtn.disabled = false;

            // Mostrar informa√ß√µes do √°udio
            showAudioInfo(audioBuffer, file);

        } catch (decodeError) {
            // Erro ao decodificar - formato n√£o suportado
            throw new Error('Formato de √°udio n√£o suportado pelo navegador. Use WAV ou MP3 de alta qualidade.');
        }

    } catch (error) {
        uploadArea.classList.add('error');
        uploadArea.querySelector('p').innerHTML = `<strong>‚ùå Erro ao carregar</strong>`;
        showError(error.message);
    }
}

async function autotune(buffer, sampleRate, strength, scale) {
    const windowSize = 4096; // Janela maior = melhor detec√ß√£o
    const hopSize = 1024;
    const output = new Float32Array(buffer.length);
    const overlapAdd = new Float32Array(buffer.length); // Para contagem de sobreposi√ß√£o

    // Para tracking de pitch m√©dio
    let pitchSum = 0;
    let pitchCount = 0;
    let lastDisplayedPitch = 0;

    // Para coleta de dados de frequ√™ncia
    lastNoteStartTime = 0;

    // Processar em janelas com yield para n√£o travar
    const totalWindows = Math.floor((buffer.length - windowSize) / hopSize);
    let windowCount = 0;

    for (let i = 0; i < buffer.length - windowSize; i += hopSize) {
        // Criar janela
        const window = new Float32Array(windowSize);
        for (let j = 0; j < windowSize; j++) {
            window[j] = buffer[i + j];
        }

        // Detectar pitch
        const pitch = detectPitch(window, sampleRate);

        if (pitch > 0) {
            // Acumular para estat√≠sticas
            pitchSum += pitch;
            pitchCount++;

            // Encontrar nota mais pr√≥xima na escala
            const targetPitch = closestNoteInScale(pitch, scale);
            const noteName = getNoteName(targetPitch);

            // Coletar dados musicais - detectar mudan√ßa de nota com buffer para evitar notas fantasma
            const currentTime = (i / sampleRate);

            // Adicionar ao buffer de mudan√ßa de nota
            noteChangeBuffer.push({
                pitch: noteName,
                time: currentTime,
                frequency: targetPitch
            });

            // Manter apenas √∫ltimas 5 detec√ß√µes no buffer
            if (noteChangeBuffer.length > 5) {
                noteChangeBuffer.shift();
            }

            // Verificar se h√° mudan√ßa consistente de nota (pelo menos 3 das √∫ltimas 5 detec√ß√µes)
            let noteChanged = false;
            if (noteChangeBuffer.length >= 3) {
                const recentPitches = noteChangeBuffer.slice(-3);
                const majorityPitch = recentPitches[0].pitch;
                const consistentCount = recentPitches.filter(n => n.pitch === majorityPitch).length;

                // Se 3 das √∫ltimas 3 detec√ß√µes s√£o consistentes e diferentes da atual
                if (consistentCount >= 3 && currentNoteData && currentNoteData.pitch !== majorityPitch) {
                    noteChanged = true;
                    lastStablePitch = majorityPitch;
                }
            }

            if (currentNoteData === null) {
                // Primeira nota
                currentNoteData = {
                    pitch: noteName,
                    startTime: currentTime,
                    sampleCount: 1
                };
                lastStablePitch = noteName;
            } else if (noteChanged && lastStablePitch !== currentNoteData.pitch) {
                // Nota mudou consistentemente - salvar a anterior e come√ßar nova
                const duration = currentTime - currentNoteData.startTime;
                const noteType = calculateNoteType(duration, 30); // 30 BPM

                // S√≥ adicionar se a dura√ß√£o for significativa (> 50ms)
                if (duration > 0.05) {
                    musicalNotes.push({
                        pitch: currentNoteData.pitch,
                        type: noteType,
                        dot: false,
                        accidental: null
                    });
                }

                // Come√ßar nova nota
                currentNoteData = {
                    pitch: lastStablePitch,
                    startTime: currentTime,
                    sampleCount: 1
                };

                // Limpar buffer ap√≥s mudan√ßa confirmada
                noteChangeBuffer = [];
            } else {
                // Mesma nota - incrementar contador
                currentNoteData.sampleCount++;
            }

            // Calcular corre√ß√£o - aplicar strength como fator de "velocidade"
            const ratio = targetPitch / pitch;
            const finalRatio = 1 + (ratio - 1) * strength;

            // Phase vocoder simplificado para melhor qualidade
            const fftSize = windowSize;
            const shiftedWindow = phaseVocoder(window, finalRatio, fftSize);

            // Aplicar janela de Hann e adicionar
            for (let j = 0; j < shiftedWindow.length && i + j < output.length; j++) {
                const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * j / windowSize));
                output[i + j] += shiftedWindow[j] * hannWindow;
                overlapAdd[i + j] += hannWindow;
            }
        } else {
            // Sem pitch detectado, copiar original com janela
            for (let j = 0; j < windowSize && i + j < output.length; j++) {
                const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * j / windowSize));
                output[i + j] += window[j] * hannWindow;
                overlapAdd[i + j] += hannWindow;
            }
        }

        // Atualizar progresso e dar chance ao navegador respirar
        windowCount++;
        if (windowCount % 50 === 0) {
            updateProgress((windowCount / totalWindows) * 100);
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Finalizar a √∫ltima nota se existir (apenas se dura√ß√£o significativa)
    if (currentNoteData !== null) {
        const finalTime = buffer.length / sampleRate;
        const duration = finalTime - currentNoteData.startTime;

        // S√≥ adicionar se a dura√ß√£o for significativa (> 50ms)
        if (duration > 0.05) {
            const noteType = calculateNoteType(duration, 30);
            musicalNotes.push({
                pitch: currentNoteData.pitch,
                type: noteType,
                dot: false,
                accidental: null
            });
        }
    }

    // Normalizar pela sobreposi√ß√£o
    for (let i = 0; i < output.length; i++) {
        if (overlapAdd[i] > 0) {
            output[i] /= overlapAdd[i];
        }
    }

    // Normalizar amplitude
    let max = 0;
    for (let i = 0; i < output.length; i++) {
        const abs = Math.abs(output[i]);
        if (abs > max) max = abs;
    }

    if (max > 0) {
        const normFactor = 0.95 / max; // Deixa margem para evitar clipping
        for (let i = 0; i < output.length; i++) {
            output[i] *= normFactor;
        }
    }

    return output;
}

async function processAudio() {
    if (!audioBuffer) return;

    const processBtn = document.getElementById('processBtn');
    const progress = document.getElementById('progress');

    processBtn.disabled = true;
    progress.style.display = 'block';
    musicalNotes = []; // Limpar dados anteriores
    currentNoteData = null; // Limpar dados da nota atual
    lastNoteStartTime = 0; // Resetar tempo inicial
    hideError();

    const strengthSlider = document.getElementById('strength');
    const scaleSelect = document.getElementById('scale');

    const strength = strengthSlider.value / 100;
    const selectedScale = scales[scaleSelect.value];

    try {
        // Processar cada canal
        const channels = [];
        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
            updateProgress(0, `Processando canal ${ch + 1}/${audioBuffer.numberOfChannels}...`);
            const channelData = audioBuffer.getChannelData(ch);
            const processed = await autotune(channelData, audioBuffer.sampleRate, strength, selectedScale);
            channels.push(processed);
        }

        // Criar buffer de sa√≠da
        processedBuffer = audioContext.createBuffer(
            channels.length,
            channels[0].length,
            audioBuffer.sampleRate
        );

        channels.forEach((channel, i) => {
            processedBuffer.copyToChannel(channel, i);
        });

        updateProgress(100, 'Processamento conclu√≠do! Importando notas para a partitura...');
        setTimeout(() => {
            progress.style.display = 'none';
            // Importar as notas detectadas para a partitura
            importMusicalNotesToScore();
            processBtn.disabled = false;
        }, 1000);

    } catch (error) {
        showError('Erro ao processar: ' + error.message);
        progress.style.display = 'none';
        processBtn.disabled = false;
    }
}

function importMusicalNotesToScore() {
    if (musicalNotes.length === 0) {
        showError('Nenhuma nota musical foi detectada no √°udio.');
        return;
    }

    // Limpar partitura atual
    staffs = Array.from({ length: 4 }, (_, i) => ({
        id: Date.now() + i,
        staves: [
            { clef: 'treble', notes: [], label: i === 0 ? 'P1' : '' },
            { clef: 'bass', notes: [], label: '' }
        ]
    }));
    currentSystemIndex = 0;
    currentStaffIndex = 0;
    isEditing = false; // √Åudio processado j√° vem formatado

    // Organizar notas sequencialmente na primeira pauta do primeiro sistema
    let targetStaff = staffs[0].staves[0];

    // Converter cada nota detectada para o formato da partitura
    musicalNotes.forEach(note => {
        const convertedNote = convertNoteForScore(note);
        targetStaff.notes.push([convertedNote]);
        
        // Verificar se precisa de novo sistema durante a importa√ß√£o
        const totalBeats = calculateSystemBeats(staffs[currentSystemIndex]);
        if (totalBeats >= MAX_BEATS_PER_SYSTEM) {
            currentSystemIndex++;
            if (currentSystemIndex >= staffs.length) {
                const lastSystem = staffs[staffs.length - 1];
                const newStaves = lastSystem.staves.map(s => ({
                    clef: s.clef,
                    notes: [],
                    label: ''
                }));
                staffs.push({
                    id: Date.now(),
                    staves: newStaves
                });
            }
            targetStaff = staffs[currentSystemIndex].staves[0];
        }
    });

    currentSystemIndex = 0;
    redraw();

    // Mostrar mensagem de sucesso
    const successMessage = document.createElement('div');
    successMessage.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #48bb78;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 1000;
        font-weight: bold;
    `;
    successMessage.textContent = `‚úì ${musicalNotes.length} notas importadas para a partitura!`;
    document.body.appendChild(successMessage);

    setTimeout(() => {
        document.body.removeChild(successMessage);
    }, 3000);
}

function convertNoteForScore(note) {
    // Converte uma nota do formato autotune para o formato da partitura
    // Exemplo: "C4" -> "C4", "C#4" -> "C4" com accidental, etc.

    const pitch = note.pitch;
    let convertedPitch = pitch;
    let accidental = null;

    // Verificar se h√° acidente na nota (sustenido ou bemol)
    if (pitch.includes('#')) {
        convertedPitch = pitch.replace('#', '');
        accidental = 'sharp';
    } else if (pitch.includes('b') || pitch.includes('‚ô≠')) {
        convertedPitch = pitch.replace('b', '').replace('‚ô≠', '');
        accidental = 'flat';
    }

    return {
        pitch: convertedPitch,
        type: note.type,
        dot: note.dot || false,
        accidental: accidental
    };
}

function getDurationInBeats(noteType, dot, bottomNumber) {
    const baseDurations = {
        "semibreve": 4, "minima": 2, "seminima": 1, "colcheia": 0.5, "semicolcheia": 0.25,
        "pausa-semibreve": 4, "pausa-minima": 2, "pausa-seminima": 1, 
        "pausa-colcheia": 0.5, "pausa-semicolcheia": 0.25
    };
    let duration = baseDurations[noteType] || 1;
    if (bottomNumber === 8) duration *= 0.5;
    else if (bottomNumber === 2) duration *= 2;
    if (dot) duration *= 1.5;
    return duration;
}
function drawAccidental(acc, x, y) {
    ctx.font = "24px Arial";
    ctx.fillStyle = "#333";
    const symbol = acc === 'sharp' ? '‚ôØ' : acc === 'flat' ? '‚ô≠' : '‚ôÆ';
    ctx.fillText(symbol, x - 20, y + 8);
}
function drawDot(x, y) {
    ctx.beginPath();
    ctx.arc(x + 18, y, 3, 0, Math.PI * 2);
    ctx.fillStyle = "#333";
    ctx.fill();
}
function drawSemibreve(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawMinima(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawSeminima(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawColcheia(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 10, y - 40);
    ctx.quadraticCurveTo(x + 26, y - 33, x + 10, y - 20);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawSemicolcheia(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 10, y - 40);
    ctx.quadraticCurveTo(x + 26, y - 33, x + 10, y - 20);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 10, y - 35);
    ctx.quadraticCurveTo(x + 26, y - 28, x + 10, y - 15);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawRest(type, x, staffY) {
    ctx.font = "32px Arial";
    ctx.fillStyle = "#333";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const symbols = {
        'pausa-semibreve': 'ùÑª',
        'pausa-minima': 'ùÑº',
        'pausa-seminima': 'ùÑΩ',
        'pausa-colcheia': 'ùÑæ',
        'pausa-semicolcheia': 'ùÑø'
    };
    const symbol = symbols[type] || '';
    
    // Posicionar no meio da pauta
    let y = staffY + 40;
    if (type === 'pausa-semibreve') y -= 10;
    if (type === 'pausa-minima') y += 10;
    
    ctx.fillText(symbol, x, y);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
}
function drawNote(note, x, y) {
    if (note.type.startsWith('pausa-')) {
        drawRest(note.type, x, y);
        return;
    }
    const dot = note.dot;
    if (note.type === "semibreve") drawSemibreve(x, y, dot);
    else if (note.type === "minima") drawMinima(x, y, dot);
    else if (note.type === "seminima") drawSeminima(x, y, dot);
    else if (note.type === "colcheia") drawColcheia(x, y, dot);
    else if (note.type === "semicolcheia") drawSemicolcheia(x, y, dot);
}
function drawLedgerLines(x, y, staffY, clef) {
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1.5;
    const topStaffLine = staffY;
    const bottomStaffLine = staffY + STAFF_HEIGHT;
    
    if (y < topStaffLine) {
        for (let lineY = topStaffLine - 20; lineY >= y - 5; lineY -= 20) {
            ctx.beginPath();
            ctx.moveTo(x - 15, lineY);
            ctx.lineTo(x + 15, lineY);
            ctx.stroke();
        }
    }
    if (y > bottomStaffLine) {
        for (let lineY = bottomStaffLine + 20; lineY <= y + 5; lineY += 20) {
            ctx.beginPath();
            ctx.moveTo(x - 15, lineY);
            ctx.lineTo(x + 15, lineY);
            ctx.stroke();
        }
    }
}

function drawBarline(x, y) {
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + STAFF_HEIGHT);
    ctx.stroke();
}

function drawKeySharps(staffY, clef) {
    const positions = clef === 'treble' ? 
        ['F5', 'C5', 'G5', 'D5', 'A4', 'E5', 'B4'] :
        ['F3', 'C3', 'G3', 'D3', 'A2', 'E3', 'B2'];
    const noteYMap = clef === 'treble' ? noteYTreble : noteYBass;
    
    ctx.font = "24px Arial";
    ctx.fillStyle = "#333";
    ctx.textBaseline = "middle";
    for (let i = 0; i < keySharps; i++) {
        const pitch = positions[i];
        const x = 80 + (i * 12);
        const y = noteYMap[pitch] + staffY;
        ctx.fillText("‚ôØ", x, y);
    }
}

function drawKeyFlats(staffY, clef) {
    const positions = clef === 'treble' ?
        ['B4', 'E5', 'A4', 'D5', 'G4', 'C5', 'F4'] :
        ['B2', 'E3', 'A2', 'D3', 'G2', 'C3', 'F2'];
    const noteYMap = clef === 'treble' ? noteYTreble : noteYBass;
    
    ctx.font = "24px Arial";
    ctx.fillStyle = "#333";
    ctx.textBaseline = "middle";
    for (let i = 0; i < keyFlats; i++) {
        const pitch = positions[i];
        const x = 80 + (i * 12);
        const y = noteYMap[pitch] + staffY;
        // O bemol (‚ô≠) costuma ficar um pouco acima do centro visual para alinhar o bojo
        ctx.fillText("‚ô≠", x, y - 2);
    }
}

function updateDynamicMargins() {
    const keyAccidentals = Math.max(keySharps, keyFlats);
    const keySignatureWidth = keyAccidentals > 0 ? (keyAccidentals * 12) : 0;
    
    // Posi√ß√µes base originais
    const baseTimeSignatureX = 110;
    const baseClefMargin = 130;
    
    // Se a armadura avan√ßar muito, empurramos o compasso
    // A armadura termina em 80 + keySignatureWidth
    // Queremos pelo menos 25px de espa√ßo entre o fim da armadura e o centro do compasso
    timeSignatureX = Math.max(baseTimeSignatureX, 80 + keySignatureWidth + 25);
    
    // E as notas devem vir depois do compasso (pelo menos 20px ap√≥s o centro do compasso)
    CLEF_MARGIN = Math.max(baseClefMargin, timeSignatureX + 20);
}

function drawTimeSignature(x, staffY) {
    ctx.font = "bold 28px Georgia, serif";
    ctx.fillStyle = "#333";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const centerY = staffY + 40;
    ctx.fillText(timeSignature.top.toString(), x, centerY - 20);
    ctx.fillText(timeSignature.bottom.toString(), x, centerY + 20);
    ctx.textAlign = "left";
}

function drawSingleStaff(staffY, clef, isActive = false, label = "") {
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1.5;
    
    // Desenhar label se houver
    if (label) {
        ctx.font = "italic 14px Arial";
        ctx.fillStyle = "#666";
        ctx.fillText(label, 10, staffY + 45);
    }

    for (let i = 0; i < 5; i++) {
        const y = staffY + i * 20;
        ctx.beginPath();
        ctx.moveTo(20, y);
        ctx.lineTo(canvas.width - 20, y);
        ctx.stroke();
    }
    
    if (isActive) {
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
        ctx.lineWidth = 2;
        ctx.strokeRect(15, staffY - 10, canvas.width - 35, STAFF_HEIGHT + 20);
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1.5;
    }
    
    if (clef === 'treble') {
        ctx.font = "70px 'Segoe UI Symbol', 'Noto Sans Symbols', Arial, sans-serif"; 
        ctx.fillStyle = "#333";
        ctx.textBaseline = "top";
        ctx.fillText("ùÑû", 35, staffY - 2);
    } else {
        ctx.font = "50px 'Segoe UI Symbol', 'Noto Sans Symbols', Arial, sans-serif";
        ctx.fillStyle = "#333";
        ctx.textBaseline = "top";
        ctx.fillText("ùÑ¢", 35, staffY - 2);
    }
    
    if (keySharps > 0) drawKeySharps(staffY, clef);
    else if (keyFlats > 0) drawKeyFlats(staffY, clef);
    
    drawTimeSignature(timeSignatureX, staffY);
    
    // Fim da pauta
    ctx.beginPath();
    ctx.moveTo(canvas.width - 20, staffY);
    ctx.lineTo(canvas.width - 20, staffY + STAFF_HEIGHT);
    ctx.stroke();
}

function drawSystem(systemIndex) {
    const system = staffs[systemIndex];
    const systemY = systemIndex * SYSTEM_SPACING;
    const isCurrentSystem = systemIndex === currentSystemIndex;
    
    system.staves.forEach((staff, i) => {
        const staffY = systemY + 80 + i * (STAFF_HEIGHT + STAFF_GAP);
        const isActive = isCurrentSystem && i === currentStaffIndex;
        drawSingleStaff(staffY, staff.clef, isActive, staff.label);
    });
    
    // Colchete inicial do sistema
    const firstStaffY = systemY + 80;
    const lastStaffY = systemY + 80 + (system.staves.length - 1) * (STAFF_HEIGHT + STAFF_GAP) + STAFF_HEIGHT;
    
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(15, firstStaffY);
    ctx.lineTo(15, lastStaffY);
    ctx.stroke();
    
    // Pequenos tra√ßos horizontais no in√≠cio
    ctx.lineWidth = 2;
    system.staves.forEach((_, i) => {
        const staffY = systemY + 80 + i * (STAFF_HEIGHT + STAFF_GAP);
        ctx.beginPath();
        ctx.moveTo(15, staffY);
        ctx.lineTo(20, staffY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(15, staffY + STAFF_HEIGHT);
        ctx.lineTo(20, staffY + STAFF_HEIGHT);
        ctx.stroke();
    });
}

function redraw() {
    updateDynamicMargins();
    let maxBeatsCount = 0;
    let maxX = MIN_SCORE_WIDTH;

    staffs.forEach(system => {
        const beats = calculateSystemBeats(system);
        if (beats > maxBeatsCount) maxBeatsCount = beats;
        
        system.staves.forEach(staff => {
            staff.notes.forEach(chord => {
                if (chord[0].x > maxX) maxX = chord[0].x;
            });
        });
    });
    
    if (isEditing) {
        canvas.width = Math.max(MIN_SCORE_WIDTH, maxX + 100);
    } else {
        const maxMeasures = Math.ceil(maxBeatsCount / timeSignature.top) || 1;
        const mWidth = Math.max(160, timeSignature.top * 40);
        canvas.width = Math.max(MIN_SCORE_WIDTH, CLEF_MARGIN + maxMeasures * mWidth + 60);
    }
    
    const requiredHeight = staffs.length * SYSTEM_SPACING + 100;
    canvas.height = requiredHeight;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // T√≠tulo e info do sistema
    ctx.font = "bold 16px Arial";
    ctx.fillStyle = "#3b82f6";
    const currentStaff = staffs[currentSystemIndex].staves[currentStaffIndex];
    ctx.fillText(`üìù Sistema: ${currentSystemIndex + 1}/${staffs.length} | Pauta: ${currentStaffIndex + 1} (${currentStaff.clef === 'treble' ? 'Sol' : 'F√°'}) | ${isEditing ? 'MODO EDI√á√ÉO LIVRE' : 'MODO FINALIZADO'}`, 20, 25);
    
    let globalMeasureCounter = 1;
    staffs.forEach((system, systemIndex) => {
        drawSystem(systemIndex);
        const systemY = systemIndex * SYSTEM_SPACING;
        
        // --- C√ÅLCULO DE ALINHAMENTO VERTICAL (Modo Finalizado) ---
        let currentSystemMeasures = 0;
        if (!isEditing) {
            const systemTiming = system.staves.map(staff => {
                let beat = 0;
                return staff.notes.map(chord => {
                    const startBeat = beat;
                    const duration = getDurationInBeats(chord[0].type, chord[0].dot, timeSignature.bottom);
                    beat += duration;
                    return { startBeat, duration };
                });
            });

            const maxSystemBeats = calculateSystemBeats(system);
            const numMeasures = Math.ceil(maxSystemBeats / timeSignature.top) || 1;
            currentSystemMeasures = numMeasures;
            const measureWidth = (canvas.width - CLEF_MARGIN - 60) / numMeasures;

            system.staves.forEach((staff, sIdx) => {
                const staffT = systemTiming[sIdx];
                staff.notes.forEach((chord, cIdx) => {
                    const tInfo = staffT[cIdx];
                    const mIdx = Math.floor(tInfo.startBeat / timeSignature.top);
                    const mStartBeat = mIdx * timeSignature.top;
                    const mX = CLEF_MARGIN + mIdx * measureWidth;

                    const notesInM = staffT.filter(nt => nt.startBeat >= mStartBeat && nt.startBeat < mStartBeat + timeSignature.top);
                    
                    if ((chord[0].type === 'semibreve' || chord[0].type === 'pausa-semibreve') && notesInM.length === 1) {
                        chord[0].renderX = mX + measureWidth / 2;
                    } else {
                        const beatInM = tInfo.startBeat - mStartBeat;
                        const innerWidth = measureWidth - 40;
                        chord[0].renderX = mX + 20 + (beatInM / timeSignature.top) * innerWidth;
                    }
                });
            });

            system.barlinesX = [];
            for(let i=1; i<=numMeasures; i++) {
                system.barlinesX.push(CLEF_MARGIN + i * measureWidth);
            }
            system.measureWidth = measureWidth;
        }

        system.staves.forEach((staff, staffIndex) => {
            const staffYBase = systemY + 80 + staffIndex * (STAFF_HEIGHT + STAFF_GAP);
            let x = CLEF_MARGIN;

            staff.notes.forEach((chord, chordIndex) => {
                const drawX = isEditing ? (chord[0].x || x) : (chord[0].renderX || x);
                
                chord.forEach(note => {
                    if (note.type.startsWith('pausa-')) {
                        // N√£o mostrar pausas na clave de f√° durante a edi√ß√£o (pedido do usu√°rio)
                        if (isEditing && staff.clef === 'bass') return;
                        drawRest(note.type, drawX, staffYBase);
                    } else {
                        const noteYPos = noteYMapByClef(staff.clef)[note.pitch] + staffYBase;
                        drawLedgerLines(drawX, noteYPos, staffYBase, staff.clef);
                        if (note.accidental) drawAccidental(note.accidental, drawX, noteYPos);
                        drawNote(note, drawX, noteYPos);
                    }
                });
                
                if (isEditing) x += SPACING;
            });

            // Desenhar barlines alinhadas se estiver finalizado
            if (!isEditing && system.barlinesX) {
                system.barlinesX.forEach((barX, idx) => {
                    drawBarline(barX, staffYBase);
                    // N√∫mero do compasso acima da primeira pauta do sistema
                    if (staffIndex === 0) {
                        ctx.font = "bold 12px Arial";
                        ctx.fillStyle = "#1a73e8";
                        const mNum = globalMeasureCounter + idx;
                        ctx.fillText(mNum, barX - system.measureWidth + 5, staffYBase - 10);
                    }
                });
            }
        });
        if (!isEditing) globalMeasureCounter += currentSystemMeasures;
    });
    updateStaffIndicator();
}

function noteYMapByClef(clef) {
    return clef === 'treble' ? noteYTreble : noteYBass;
}
let piano = null;
async function initPiano() {
    if (piano) return;
    piano = new Tone.Sampler({
        urls: {
            "C4": "C4.mp3",
            "D#4": "Ds4.mp3",
            "F#4": "Fs4.mp3",
            "A4": "A4.mp3",
        },
        release: 1,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
    }).toDestination();
    await Tone.loaded();
}
function freqToNoteName(freq) {
    const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const A4 = 440;
    const C0 = A4 * Math.pow(2, -4.75);
    let halfSteps = Math.round(12 * Math.log2(freq / C0));
    const octave = Math.floor(halfSteps / 12);
    return notes[halfSteps % 12] + octave;
}
async function playFreq(freq, duration, startTime = 0) {
    await initPiano();
    const note = freqToNoteName(freq);
    piano.triggerAttackRelease(note, duration, Tone.now() + startTime, 0.6);
}
async function playScore() {
    await initPiano();
    await Tone.start();
    
    let allChords = [];
    
    // Aplanar todos os sistemas para uma sequ√™ncia de acordes (combinando todas as pautas)
    staffs.forEach(system => {
        let maxNotes = 0;
        system.staves.forEach(s => {
            if (s.notes.length > maxNotes) maxNotes = s.notes.length;
        });
        
        for (let i = 0; i < maxNotes; i++) {
            let combinedChord = [];
            system.staves.forEach(s => {
                if (i < s.notes.length) {
                    combinedChord.push(...s.notes[i]);
                }
            });
            allChords.push(combinedChord);
        }
    });

    if (allChords.length === 0) {
        alert("Adicione notas primeiro!");
        return;
    }
    
    let t = 0;
    const beatDuration = 60 / tempo;
    
    for (const chord of allChords) {
        if (chord.length === 0) continue;
        
        // Usamos a dura√ß√£o da primeira nota do acorde como refer√™ncia para o tempo
        const baseNote = chord[0];
        let duration = getDurationInBeats(baseNote.type, baseNote.dot, timeSignature.bottom) * beatDuration;
        
        for (const note of chord) {
            if (note.type.startsWith('pausa-')) continue;
            
            let freq = freqs[note.pitch];
            if (!freq) continue;

            // Aplica acidentes da armadura de clave
            if (!note.accidental) {
                const sharpOrder = ['F', 'C', 'G', 'D', 'A', 'E', 'B'];
                const flatOrder = ['B', 'E', 'A', 'D', 'G', 'C', 'F'];
                const noteLetter = note.pitch[0];
                
                if (keySharps > 0) {
                    if (sharpOrder.slice(0, keySharps).includes(noteLetter)) {
                        freq *= SHARP_FACTOR;
                    }
                } else if (keyFlats > 0) {
                    if (flatOrder.slice(0, keyFlats).includes(noteLetter)) {
                        freq *= FLAT_FACTOR;
                    }
                }
            }

            if (note.accidental === 'sharp') freq *= SHARP_FACTOR;
            else if (note.accidental === 'flat') freq *= FLAT_FACTOR;
            
            await playFreq(freq, duration, t);
        }
        t += duration;
    }
}
function exportToJSON() {
    const data = {
        version: "1.1", // Incrementada a vers√£o para o novo formato
        title: document.getElementById('title-input').value,
        composer: document.getElementById('composer-input').value,
        tempo: tempo,
        timeSignature: timeSignature,
        keySignature: { sharps: keySharps, flats: keyFlats },
        staffs: staffs
    };
    const json = JSON.stringify(data);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${data.title.replace(/\s+/g, '_')}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

function importFromJSON(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            if (data.version !== "1.0" && data.version !== "1.1") {
                alert("Vers√£o incompat√≠vel");
                return;
            }
            tempo = data.tempo || 120;
            timeSignature.top = data.timeSignature.top || 4;
            timeSignature.bottom = data.timeSignature.bottom || 4;
            keySharps = data.keySignature.sharps || 0;
            keyFlats = data.keySignature.flats || 0;
            
            // Migrar do formato antigo se necess√°rio
            if (data.version === "1.0") {
                staffs = data.staffs.map(grandStaff => ({
                    id: Date.now() + Math.random(),
                    staves: [
                        { clef: 'treble', notes: grandStaff[0].notes, label: 'P1' },
                        { clef: 'bass', notes: grandStaff[1].notes, label: '' }
                    ]
                }));
            } else {
                staffs = data.staffs;
            }
            
            currentSystemIndex = 0;
            currentStaffIndex = 0;
            document.getElementById('title-input').value = data.title || '';
            document.getElementById('composer-input').value = data.composer || '';
            document.getElementById('tempo-input').value = tempo;
            document.getElementById('time-top').value = timeSignature.top;
            document.getElementById('time-bottom').value = timeSignature.bottom;
            redraw();
            alert("Importado com sucesso!");
        } catch (error) {
            console.error(error);
            alert("Erro ao carregar arquivo");
        }
    };
    reader.readAsText(file);
}
function exportToMusicXML() {
    const title = document.getElementById('title-input').value;
    const composer = document.getElementById('composer-input').value;
    let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <work><work-title>${title}</work-title></work>
  <identification><creator type="composer">${composer}</creator></identification>
  <part-list><score-part id="P1"><part-name>Piano</part-name></score-part></part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>4</divisions>
        <key><fifths>${keySharps - keyFlats}</fifths></key>
        <time><beats>${timeSignature.top}</beats><beat-type>${timeSignature.bottom}</beat-type></time>
        <clef><sign>G</sign><line>2</line></clef>
      </attributes>
    </measure>
  </part>
</score-partwise>`;
    const blob = new Blob([xml], { type: 'application/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title.replace(/\s+/g, '_')}.musicxml`;
    a.click();
    URL.revokeObjectURL(url);
}
function exportToPDF() {
    const title = document.getElementById('title-input').value;
    const composer = document.getElementById('composer-input').value;
    const pdfCanvas = document.createElement('canvas');
    pdfCanvas.width = canvas.width;
    pdfCanvas.height = canvas.height + 100;
    const pdfCtx = pdfCanvas.getContext('2d');
    pdfCtx.fillStyle = 'white';
    pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    pdfCtx.fillStyle = 'black';
    pdfCtx.font = 'bold 24px Arial';
    pdfCtx.textAlign = 'center';
    pdfCtx.fillText(title, pdfCanvas.width / 2, 40);
    if (composer) {
        pdfCtx.font = '16px Arial';
        pdfCtx.fillText(composer, pdfCanvas.width / 2, 70);
    }
    pdfCtx.drawImage(canvas, 0, 100);
    pdfCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${title.replace(/\s+/g, '_')}.png`;
        a.click();
        URL.revokeObjectURL(url);
    });
}
redraw();

// Event listeners para upload de √°udio
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('audioFile');
const processBtn = document.getElementById('processBtn');
const strengthSlider = document.getElementById('strength');
const strengthValue = document.getElementById('strengthValue');

uploadArea.addEventListener('click', () => fileInput.click());

uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.style.background = '#f0f4ff';
});

uploadArea.addEventListener('dragleave', () => {
    uploadArea.style.background = '';
});

uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.style.background = '';
    if (e.dataTransfer.files.length) {
        fileInput.files = e.dataTransfer.files;
        handleFileSelect();
    }
});

fileInput.addEventListener('change', handleFileSelect);

strengthSlider.addEventListener('input', (e) => {
    strengthValue.textContent = e.target.value + '%';
});

processBtn.addEventListener('click', processAudio);

// Event listeners para metadados
document.getElementById('title-input').addEventListener('input', (e) => {
    redraw();
});
document.getElementById('composer-input').addEventListener('input', (e) => {
    redraw();
});
document.getElementById('tempo-input').addEventListener('change', (e) => {
    tempo = parseInt(e.target.value) || 120;
    redraw();
});

// Atalhos de Teclado para Efici√™ncia
document.addEventListener('keydown', (e) => {
    // N√£o disparar atalhos se estiver digitando em um input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

    switch(e.key.toLowerCase()) {
        case 'n':
            document.getElementById('note-mode-btn').click();
            break;
        case 'p':
            document.getElementById('rest-mode-btn').click();
            break;
        case 'h':
            document.getElementById('harmony-btn').click();
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                document.getElementById('undo-btn').click();
            }
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                exportToJSON();
            }
            break;
        case ' ': // Espa√ßo para tocar
            e.preventDefault();
            document.getElementById('play-btn').click();
            break;
    }
});

document.getElementById('time-top').addEventListener('change', (e) => {
    timeSignature.top = parseInt(e.target.value);
    redraw();
});
document.getElementById('time-bottom').addEventListener('change', (e) => {
    timeSignature.bottom = parseInt(e.target.value);
    redraw();
});
document.getElementById('note-mode-btn').addEventListener('click', () => {
    isNoteMode = true;
    isHarmonyMode = false;
    document.getElementById('note-mode-btn').classList.add('selected');
    document.getElementById('rest-mode-btn').classList.remove('selected');
    document.getElementById('harmony-btn').classList.remove('active');
});
document.getElementById('rest-mode-btn').addEventListener('click', () => {
    isNoteMode = false;
    isHarmonyMode = false;
    document.getElementById('rest-mode-btn').classList.add('selected');
    document.getElementById('note-mode-btn').classList.remove('selected');
    document.getElementById('harmony-btn').classList.remove('active');
});
document.getElementById('finish-edit-btn').addEventListener('click', () => {
    if (!isEditing) return;
    
    // Formata√ß√£o: ordenar notas por X e organizar em compassos
    isEditing = false;
    
    staffs.forEach(system => {
        system.staves.forEach(staff => {
            // Ordenar por X
            staff.notes.sort((a, b) => (a[0].x || 0) - (b[0].x || 0));
        });
    });
    
    document.getElementById('finish-edit-btn').style.display = 'none';
    redraw();
});
document.querySelectorAll('.accidental-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const accType = btn.dataset.accidental;
        if (selectedAccidental === accType) {
            selectedAccidental = null;
            btn.classList.remove('selected');
        } else {
            document.querySelectorAll('.accidental-btn').forEach(b => b.classList.remove('selected'));
            selectedAccidental = accType;
            btn.classList.add('selected');
        }
    });
});
document.getElementById('key-sharp-up').addEventListener('click', () => {
    if (keyFlats > 0) {
        alert('Remova os bem√≥is antes');
        return;
    }
    if (keySharps < 7) {
        keySharps++;
        redraw();
    }
});
document.getElementById('key-sharp-down').addEventListener('click', () => {
    if (keySharps > 0) {
        keySharps--;
        redraw();
    }
});
document.getElementById('key-flat-up').addEventListener('click', () => {
    if (keySharps > 0) {
        alert('Remova os sustenidos antes');
        return;
    }
    if (keyFlats < 7) {
        keyFlats++;
        redraw();
    }
});
document.getElementById('key-flat-down').addEventListener('click', () => {
    if (keyFlats > 0) {
        keyFlats--;
        redraw();
    }
});
document.getElementById('key-reset').addEventListener('click', () => {
    keySharps = 0;
    keyFlats = 0;
    redraw();
});
document.getElementById('harmony-btn').addEventListener('click', () => {
    isHarmonyMode = !isHarmonyMode;
    if (isHarmonyMode) {
        isNoteMode = true;
        document.getElementById('harmony-btn').classList.add('active');
        document.getElementById('note-mode-btn').classList.remove('selected');
        document.getElementById('rest-mode-btn').classList.remove('selected');
    } else {
        // Se desativar harmonia, volta para o modo melodia (nota)
        isNoteMode = true;
        document.getElementById('harmony-btn').classList.remove('active');
        document.getElementById('note-mode-btn').classList.add('selected');
    }
});
document.getElementById('add-system-btn').addEventListener('click', () => {
    // Adicionar novo sistema (quebra de p√°gina/sistema)
    const lastSystem = staffs[staffs.length - 1];
    const newStaves = lastSystem.staves.map(s => ({
        clef: s.clef,
        notes: [],
        label: ''
    }));
    staffs.push({
        id: Date.now(),
        staves: newStaves
    });
    currentSystemIndex = staffs.length - 1;
    currentStaffIndex = 0;
    redraw();
});

document.getElementById('add-staff-btn').addEventListener('click', () => {
    // Adicionar pauta ao sistema atual
    const system = staffs[currentSystemIndex];
    const lastStaff = system.staves[system.staves.length - 1];
    system.staves.push({
        clef: lastStaff ? (lastStaff.clef === 'treble' ? 'bass' : 'treble') : 'treble',
        notes: [],
        label: ''
    });
    currentStaffIndex = system.staves.length - 1;
    redraw();
});

document.addEventListener('keydown', (e) => {
    // Atalhos para navegar entre sistemas
    if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowUp') {
        e.preventDefault();
        if (currentSystemIndex > 0) {
            currentSystemIndex--;
            redraw();
        }
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowDown') {
        e.preventDefault();
        if (currentSystemIndex < staffs.length - 1) {
            currentSystemIndex++;
            redraw();
        }
    }
    // Atalhos para navegar entre pautas do sistema atual
    if (!e.ctrlKey && !e.metaKey && e.key === 'ArrowUp') {
        if (currentStaffIndex > 0) {
            currentStaffIndex--;
            redraw();
        }
    }
    if (!e.ctrlKey && !e.metaKey && e.key === 'ArrowDown') {
        const system = staffs[currentSystemIndex];
        if (currentStaffIndex < system.staves.length - 1) {
            currentStaffIndex++;
            redraw();
        }
    }
});

document.getElementById('undo-btn').addEventListener('click', () => {
    if (undoStack.length > 0) {
        const action = undoStack.pop();
        if (action.type === 'add-chord') {
            action.staff.notes.pop();
        } else if (action.type === 'add-note') {
            const index = action.chord.indexOf(action.note);
            if (index > -1) action.chord.splice(index, 1);
        }
        redraw();
    } else {
        const system = staffs[currentSystemIndex];
        const staff = system.staves[currentStaffIndex];
        if (staff.notes.length > 0) {
            const lastChord = staff.notes[staff.notes.length - 1];
            if (lastChord.length > 1) lastChord.pop();
            else staff.notes.pop();
            redraw();
        }
    }
});

document.getElementById('clear-btn').addEventListener('click', () => {
    if (confirm("Limpar toda a partitura?")) {
        staffs = Array.from({ length: 4 }, (_, i) => ({
            id: Date.now() + i,
            staves: [
                { clef: 'treble', notes: [], label: i === 0 ? 'P1' : '' },
                { clef: 'bass', notes: [], label: '' }
            ]
        }));
        currentSystemIndex = 0;
        currentStaffIndex = 0;
        keySharps = 0;
        keyFlats = 0;
        isEditing = true;
        document.getElementById('finish-edit-btn').style.display = 'flex';
        redraw();
    }
});

document.getElementById('play-btn').addEventListener('click', playScore);

document.getElementById('download-btn').addEventListener('click', () => {
    document.getElementById('export-modal').classList.add('active');
});

document.getElementById('export-json').addEventListener('click', () => {
    exportToJSON();
    document.getElementById('export-modal').classList.remove('active');
});

document.getElementById('import-file').addEventListener('change', importFromJSON);

document.getElementById('export-musicxml').addEventListener('click', () => {
    exportToMusicXML();
    document.getElementById('export-modal').classList.remove('active');
});

document.getElementById('export-pdf').addEventListener('click', () => {
    exportToPDF();
    document.getElementById('export-modal').classList.remove('active');
});

document.getElementById('export-cancel').addEventListener('click', () => {
    document.getElementById('export-modal').classList.remove('active');
});

document.getElementById('export-modal').addEventListener('click', (e) => {
    if (e.target.id === 'export-modal') {
        e.target.classList.remove('active');
    }
});

// Help Modal Events
document.getElementById('help-close').addEventListener('click', () => {
    document.getElementById('help-modal').classList.remove('active');
});

document.getElementById('how-to-edit-btn').addEventListener('click', () => {
    document.getElementById('help-modal').classList.add('active');
});

document.getElementById('help-modal').addEventListener('click', (e) => {
    if (e.target.id === 'help-modal') {
        e.target.classList.remove('active');
    }
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

canvas.addEventListener('mousedown', async (e) => {
    // Iniciar √°udio se necess√°rio (exig√™ncia do navegador)
    if (Tone.context.state !== 'running') {
        await Tone.start();
    }

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clickX = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;
    
    // Identificar qual pauta e sistema foram clicados baseado na proximidade
    let targetSystemIndex = -1;
    let targetStaffIndex = -1;
    let minStaffDist = Infinity;

    staffs.forEach((system, sIdx) => {
        const systemY = sIdx * SYSTEM_SPACING;
        system.staves.forEach((staff, stIdx) => {
            const staffY = systemY + 80 + stIdx * (STAFF_HEIGHT + STAFF_GAP);
            const staffCenter = staffY + STAFF_HEIGHT / 2;
            const dist = Math.abs(clickY - staffCenter);
            
            // Verificamos se o clique est√° dentro da √°rea estendida da pauta (ledger lines)
            if (clickY >= staffY - 120 && clickY <= staffY + STAFF_HEIGHT + 120) {
                if (dist < minStaffDist) {
                    minStaffDist = dist;
                    targetSystemIndex = sIdx;
                    targetStaffIndex = stIdx;
                }
            }
        });
    });
    
    if (targetStaffIndex === -1) return;
    
    currentSystemIndex = targetSystemIndex;
    currentStaffIndex = targetStaffIndex;
    const system = staffs[currentSystemIndex];
    const systemY = currentSystemIndex * SYSTEM_SPACING;
    const staff = system.staves[currentStaffIndex];
    currentClef = staff.clef;
    
    // Verificar se clicou em uma nota existente para mudar a dura√ß√£o
    let clickedChord = null;
    let staffYBase = systemY + 80 + currentStaffIndex * (STAFF_HEIGHT + STAFF_GAP);
    const noteYMap = noteYMapByClef(staff.clef);

    staff.notes.forEach(chord => {
        const x = isEditing ? (chord[0].x || 0) : (CLEF_MARGIN + staff.notes.indexOf(chord) * SPACING);
        const distX = Math.abs(x - clickX);
        if (distX < 20) {
            // Verificar Y se n√£o for pausa
            if (chord[0].type.startsWith('pausa-')) {
                // Durante a edi√ß√£o, n√£o interagimos com pausas na clave de f√° (est√£o ocultas)
                if (isEditing && staff.clef === 'bass') return;
                clickedChord = chord;
            } else {
                // Verificar se clicou em qualquer nota do acorde com sensibilidade ajustada
                // A dist√¢ncia entre notas adjacentes √© de 10px. Usamos um threshold menor
                // para evitar confundir cliques em notas vizinhas (especialmente em harmonia)
                const yThreshold = 6; 
                chord.forEach(note => {
                    const noteYPos = noteYMap[note.pitch] + staffYBase;
                    if (Math.abs(noteYPos - clickY) < yThreshold) {
                        clickedChord = chord;
                    }
                });
            }
        }
    });

    if (clickedChord) {
        // Mudar dura√ß√£o
        const currentNote = clickedChord[0];
        const isRest = currentNote.type.startsWith('pausa-');
        const baseType = isRest ? currentNote.type.replace('pausa-', '') : currentNote.type;
        
        let currentIndex = durationSequence.findIndex(d => d.type === baseType && d.dot === currentNote.dot);
        
        if (e.button === 0) { // Clique esquerdo - Aumentar
            if (currentIndex < durationSequence.length - 1) currentIndex++;
        } else if (e.button === 2) { // Clique direito - Diminuir
            if (currentIndex > 0) currentIndex--;
        }
        
        const nextDuration = durationSequence[currentIndex];
        clickedChord.forEach(n => {
            n.type = isRest ? `pausa-${nextDuration.type}` : nextDuration.type;
            n.dot = nextDuration.dot;
        });
        
        redraw();
        return;
    }

    if (e.button !== 0) return; // S√≥ permite adicionar novas notas com clique esquerdo

    if (!isNoteMode) {
        const newNote = {
            type: "pausa-seminima",
            dot: false,
            pitch: null,
            accidental: null,
            x: CLEF_MARGIN + staff.notes.length * SPACING
        };
        if (isHarmonyMode) {
            alert('Pausas n√£o podem ser adicionadas em harmonia');
            return;
        }
        staff.notes.push([newNote]);
        undoStack.push({ type: 'add-chord', staff: staff });
        redraw();
        return;
    }

    // Usar o noteYMap j√° definido acima
    
    let bestPitch = null;
    let bestDist = Infinity;
    for (const p in noteYMap) {
        const noteAbsoluteY = noteYMap[p] + staffYBase;
        const d = Math.abs(noteAbsoluteY - clickY);
        if (d < bestDist) {
            bestDist = d;
            bestPitch = p;
        }
    }

    if (bestDist > 25) return;
    
    const newNote = {
        pitch: bestPitch,
        type: "seminima",
        dot: false,
        accidental: selectedAccidental,
        x: clickX
    };
    
    if (isHarmonyMode) {
        // Encontrar o acorde mais pr√≥ximo no eixo X em QUALQUER pauta do sistema
        let nearestChord = null;
        let minXDist = Infinity;
        let targetIndex = -1;
        let referenceStaff = null;
        
        system.staves.forEach(s => {
            s.notes.forEach((chord, idx) => {
                const chordX = isEditing ? (chord[0].x || 0) : (CLEF_MARGIN + idx * SPACING);
                const dist = Math.abs(chordX - clickX);
                if (dist < minXDist) {
                    minXDist = dist;
                    nearestChord = chord;
                    targetIndex = idx;
                    referenceStaff = s;
                }
            });
        });

        if (nearestChord && minXDist < 30) {
            // Se j√° existe um acorde na pauta ATUAL nesse √≠ndice
            let currentStaffChord = staff.notes[targetIndex];

            if (currentStaffChord) {
                const isRest = currentStaffChord[0].type.startsWith('pausa-');
                if (isRest) {
                    // Substituir pausa pela nota
                    newNote.x = currentStaffChord[0].x;
                    newNote.type = currentStaffChord[0].type.replace('pausa-', '');
                    newNote.dot = currentStaffChord[0].dot;
                    staff.notes[targetIndex] = [newNote];
                    undoStack.push({ type: 'add-chord', staff: staff });
                } else {
                    // Adicionar ao acorde existente
                    const isPitchPresent = currentStaffChord.some(n =>
                        n.pitch === bestPitch && n.accidental === selectedAccidental
                    );
                    if (!isPitchPresent) {
                        newNote.x = currentStaffChord[0].x;
                        newNote.type = currentStaffChord[0].type;
                        newNote.dot = currentStaffChord[0].dot;
                        currentStaffChord.push(newNote);
                        undoStack.push({ type: 'add-note', chord: currentStaffChord, note: newNote });
                    }
                }
            } else {
                // Se n√£o houver nada nesse √≠ndice na pauta atual, preenchemos com pausas at√© chegar l√°
                while (staff.notes.length < targetIndex) {
                    staff.notes.push([{
                        type: "pausa-seminima",
                        dot: false,
                        pitch: null,
                        accidental: null,
                        x: CLEF_MARGIN + staff.notes.length * SPACING
                    }]);
                }
                // Adiciona a nota no √≠ndice alvo, herdando a dura√ß√£o da refer√™ncia
                newNote.x = isEditing ? (nearestChord[0].x || 0) : (CLEF_MARGIN + targetIndex * SPACING);
                const refType = nearestChord[0].type;
                newNote.type = refType.startsWith('pausa-') ? refType.replace('pausa-', '') : refType;
                newNote.dot = nearestChord[0].dot;
                staff.notes[targetIndex] = [newNote];
                undoStack.push({ type: 'add-chord', staff: staff });
            }
        } else {
            // Se n√£o houver nota pr√≥xima em nenhuma pauta, cria um novo acorde no final da pauta atual
            newNote.x = CLEF_MARGIN + staff.notes.length * SPACING;
            staff.notes.push([newNote]);
            undoStack.push({ type: 'add-chord', staff: staff });
        }
    } else {
        // Modo Melodia - Adicionar nova nota ao final de forma organizada
        newNote.x = CLEF_MARGIN + staff.notes.length * SPACING;
        staff.notes.push([newNote]);
        undoStack.push({ type: 'add-chord', staff: staff });
    }
    
    selectedAccidental = null;
    document.querySelectorAll('.accidental-btn').forEach(b => b.classList.remove('selected'));
    redraw();
});
</script>    
</body>
</html>
