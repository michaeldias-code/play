<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Profissional de Partituras</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 15px;
            max-width: 100%;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 15px;
        }
        .header h1 {
            color: #333;
            font-size: 20px;
            margin-bottom: 5px;
        }
        .metadata {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .metadata input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 100%;
        }
        .meta-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .meta-row label {
            font-size: 12px;
            font-weight: 600;
            min-width: 60px;
        }
        .meta-row input[type="number"] {
            width: 60px;
            text-align: center;
        }
        .controls {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            max-height: 40vh;
            overflow-y: auto;
        }
        .control-section {
            margin-bottom: 12px;
        }
        .control-section h3 {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .button-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        button, .file-upload-label { /* Adicionado a classe para estilizar o label */
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
            display: flex; /* Para centralizar conte√∫do */
            align-items: center;
            justify-content: center;
            text-decoration: none; /* Para garantir que o label n√£o tenha sublinhado */
            color: #333;
        }
        button:active, .file-upload-label:active {
            transform: scale(0.95);
        }
        button.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        button.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        .fig-button {
            width: 45px;
            height: 45px;
            font-size: 24px;
            padding: 4px;
        }
        .fig-button canvas {
            pointer-events: none;
            max-width: 100%;
            max-height: 100%;
        }
        .accidental-btn {
            font-size: 20px;
            min-width: 45px;
        }
        .action-btn, .file-upload-label { /* Aplicando estilo de bot√£o de a√ß√£o ao label */
            padding: 10px 16px;
            font-size: 14px;
            flex: 1;
            min-width: 120px;
            /* Estilo Padr√£o (Importar) */
            background: #FF5722; /* Laranja/Importar */
            color: white;
            border-color: #FF5722;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
            background: #f8f9ff;
        }

        .upload-area:hover {
            background: #f0f4ff;
            border-color: #764ba2;
        }

        .upload-area.has-file {
            border-color: #48bb78;
            background: #f0fff4;
        }

        .upload-area.error {
            border-color: #f56565;
            background: #fff5f5;
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .audio-info {
            background: #f0fff4;
            border: 2px solid #48bb78;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 13px;
            display: none;
        }

        .audio-info strong {
            color: #2f855a;
        }

        .error-message {
            background: #fff5f5;
            border: 2px solid #f56565;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            color: #c53030;
            display: none;
        }

        .progress {
            margin-top: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .settings {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .settings label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }

        .settings input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .settings input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .settings input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            appearance: none;
        }

        .settings select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .settings select:focus {
            outline: none;
            border-color: #667eea;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .btn-process {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
            width: 100%;
        }

        .btn-process:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-process:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }
        #play-btn { background: #4CAF50; color: white; border-color: #4CAF50; }
        #clear-btn { background: #f44336; color: white; border-color: #f44336; }
        #undo-btn { background: #ff9800; color: white; border-color: #ff9800; }
        #download-btn { background: #2196F3; color: white; border-color: #2196F3; }
        #add-staff-btn { background: #9C27B0; color: white; border-color: #9C27B0; }
        .score-container {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 15px;
            max-height: 60vh;
        }
        .score-wrapper {
            min-width: 900px;
            min-height: 400px;
            padding: 20px;
        }
        #score {
            cursor: crosshair;
            display: block;
            background: white;
        }
        .info {
            text-align: center;
            color: #666;
            font-size: 12px;
            padding: 10px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 100%;
        }
        .modal h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
        }
        .modal-buttons button {
            width: 100%;
            padding: 12px;
            font-size: 14px;
        }
        @media (min-width: 768px) {
            .container { padding: 30px; max-width: 1400px; }
            .header h1 { font-size: 28px; }
            .metadata {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            .controls { max-height: none; }
            .fig-button { width: 55px; height: 55px; font-size: 28px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Editor de Partituras Profissional</h1>
        </div>
        <div class="metadata">
            <input type="text" id="title-input" placeholder="T√≠tulo da M√∫sica" value="Minha Composi√ß√£o">
            <input type="text" id="composer-input" placeholder="Compositor">
            <div class="meta-row">
                <label>Compasso:</label>
                <input type="number" id="time-top" min="1" max="16" value="4">
                <span>/</span>
                <input type="number" id="time-bottom" min="1" max="16" value="4">
            </div>
            <div class="meta-row">
                <label>Tempo (BPM):</label>
                <input type="number" id="tempo-input" min="40" max="240" value="120">
            </div>
        </div>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üéµ</div>
            <p><strong>Clique para selecionar</strong> ou arraste um arquivo de √°udio</p>
            <p style="font-size: 12px; color: #999; margin-top: 5px;">Recomendado: WAV ou MP3 de alta qualidade</p>
            <input type="file" id="audioFile" accept="audio/*">
        </div>

        <div class="error-message" id="errorMessage"></div>

        <div class="audio-info" id="audioInfo"></div>

        <div class="settings">
            <div class="setting-group">
                <label>
                    Intensidade do Autotune
                    <span class="value-display" id="strengthValue">80%</span>
                </label>
                <input type="range" id="strength" min="0" max="100" value="80">
                <p style="font-size: 12px; color: #666; margin-top: 5px;">
                    0% = natural | 100% = rob√≥tico (efeito T-Pain)
                </p>
            </div>

            <div class="setting-group">
                <label>Escala Musical</label>
                <select id="scale">
                    <option value="chromatic">Crom√°tica (todas as notas)</option>
                    <option value="major">Maior (D√≥ maior)</option>
                    <option value="minor">Menor (L√° menor)</option>
                    <option value="pentatonic">Pentat√¥nica</option>
                </select>
            </div>
        </div>

        <button class="btn-process" id="processBtn" disabled>
            üéµ Processar √Åudio e Importar para Partitura
        </button>

        <div class="progress" id="progress">
            <p id="progressText">Processando...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="controls">
            <div class="control-section">
                <h3>Figuras Normais</h3>
                <div class="button-group">
                    <!--<button class="fig-button selected" data-type="semibreve" data-dot="false">‚óã</button>-->
                    <button class="fig-button selected" data-type="semibreve" data-dot="false">&#119133;</button>
					<!--<button class="fig-button" data-type="minima" data-dot="false">ùÖóùÖ•</button>-->
					<button class="fig-button" data-type="minima" data-dot="false">&#119134;</button>
                    <button class="fig-button" data-type="seminima" data-dot="false">‚ô©</button>
                    <button class="fig-button" data-type="colcheia" data-dot="false">‚ô™</button>
                    <button class="fig-button" data-type="semicolcheia" data-dot="false">‚ô¨</button>
                </div>
            </div>
            <div class="control-section">
                <h3>Figuras Pontuadas</h3>
                <div class="button-group">
                    <button class="fig-button" data-type="semibreve" data-dot="true">&#119133;.</button>
                    <button class="fig-button" data-type="minima" data-dot="true">&#119134;.</button>
                    <button class="fig-button" data-type="seminima" data-dot="true">‚ô©.</button>
                    <button class="fig-button" data-type="colcheia" data-dot="true">‚ô™.</button>
                    <button class="fig-button" data-type="semicolcheia" data-dot="true">‚ô¨.</button>
                </div>
            </div>
            <div class="control-section">
                <h3>Pausas</h3>
                <div class="button-group">
                    <button class="fig-button" data-type="pausa-semibreve" data-dot="false">ùÑª</button>
                    <button class="fig-button" data-type="pausa-minima" data-dot="false">ùÑº</button>
                    <button class="fig-button" data-type="pausa-seminima" data-dot="false">ùÑΩ</button>
                    <button class="fig-button" data-type="pausa-colcheia" data-dot="false">ùÑæ</button>
                    <button class="fig-button" data-type="pausa-semicolcheia" data-dot="false">ùÑø</button>
                </div>
            </div>
            <div class="control-section">
                <h3>Acidentes</h3>
                <div class="button-group">
                    <button class="accidental-btn" data-accidental="sharp">‚ôØ</button>
                    <button class="accidental-btn" data-accidental="flat">‚ô≠</button>
                    <button class="accidental-btn" data-accidental="natural">‚ôÆ</button>
                </div>
            </div>
            <div class="control-section">
                <h3>Armadura de Clave</h3>
                <div class="button-group">
                    <button id="key-sharp-up">‚ôØ +</button>
                    <button id="key-sharp-down">‚ôØ -</button>
                    <button id="key-flat-up">‚ô≠ +</button>
                    <button id="key-flat-down">‚ô≠ -</button>
                    <button id="key-reset">‚ü≤</button>
                </div>
            </div>
            <div class="control-section">
                <h3>Clave Ativa</h3>
                <div class="button-group">
                    <button class="action-btn active" id="clef-treble-btn">üéº Sol</button>
                    <button class="action-btn" id="clef-bass-btn">üéπ F√°</button>
                </div>
            </div>
            <div class="control-section">
                <h3>A√ß√µes</h3>
                <div class="button-group">
                    <button class="action-btn" id="play-btn">‚ñ∂ Tocar</button>
                    <label for="import-file" class="file-upload-label action-btn" id="import-btn">üì• Importar</label>
                    <input type="file" id="import-file" accept=".json" style="display: none;">
                    <button class="action-btn" id="harmony-btn">üéµ Harmonia</button>
                    <button class="action-btn" id="add-staff-btn">‚ûï Pauta</button>
                    <button class="action-btn" id="undo-btn">‚Ü∂ Desfazer</button>
                    <button class="action-btn" id="clear-btn">‚úï Limpar</button>
                    <button class="action-btn" id="download-btn">üíæ Exportar</button>
                </div>
            </div>
        </div>
        <div class="score-container">
            <div class="score-wrapper">
                <canvas id="score"></canvas>
            </div>
        </div>
        <div class="info">
            üëÜ Clique na pauta ‚Ä¢ Barras de compasso autom√°ticas ‚Ä¢ Pautas conectadas
        </div>
    </div>
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <h2>Exportar Partitura</h2>
            <p style="margin-bottom: 15px; font-size: 14px;">Escolha o formato:</p>
            <div class="modal-buttons">
                <button id="export-json">üìÑ JSON</button>
                <button id="export-musicxml">üéº MusicXML</button>
                <button id="export-pdf">üñºÔ∏è PNG</button>
                <button id="export-cancel" style="background: #ccc;">Cancelar</button>
            </div>
        </div>
    </div>
<script>
// Editor de Partituras - Sistema de Pautas Autom√°ticas
let staffs = [[{ clef: 'treble', notes: [] }, { clef: 'bass', notes: [] }]];
let currentStaffIndex = 0;
let currentClef = 'treble';
let selectedType = "seminima";
let useDot = false;
let selectedAccidental = null;
let isHarmonyMode = false;
let keySharps = 0;
let keyFlats = 0;
let timeSignature = { top: 4, bottom: 4 };
let tempo = 120;

// Vari√°veis para processamento de √°udio
let audioBuffer = null;
let processedBuffer = null;
let audioContext = null;
let musicalNotes = []; // Array para armazenar notas musicais ao longo do tempo
let currentNoteData = null; // Dados da nota atual sendo coletada
let lastNoteStartTime = 0;
let noteChangeBuffer = []; // Buffer para confirmar mudan√ßa de nota
let lastStablePitch = null; // √öltimo pitch est√°vel detectado
const canvas = document.getElementById("score");
const ctx = canvas.getContext("2d");
const SPACING = 50;
const MIN_SCORE_WIDTH = 900;
const CLEF_MARGIN = 160;
const STAFF_OFFSET = 400;
const MAX_NOTES_PER_STAFF = 16;
const noteYTreble = {
    "C6": 40, "B5": 50, "A5": 60, "G5": 70, "F5": 80, "E5": 90,
    "D5": 100, "C5": 110, "B4": 120, "A4": 130, "G4": 140,
    "F4": 150, "E4": 160, "D4": 170, "C4": 180, "B3": 190,
    "A3": 200, "G3": 210
};
const noteYBass = {
    // Notas acima da pauta
    "E4": 220, "D4": 230, "C4": 240, "B3": 250, 
    // Notas dentro da pauta
    "A3": 260, // 5¬™ linha (topo)
    "G3": 270, 
    "F3": 280, // 4¬™ linha (Refer√™ncia da Clave de F√°)
    "E3": 290, 
    "D3": 300, // 3¬™ linha (meio)
    "C3": 310, 
    "B2": 320, // 2¬™ linha
    "A2": 330, 
    "G2": 340, // 1¬™ linha (baixo)
    // Notas abaixo da pauta
    "F2": 350, "E2": 360, "D2": 370, "C2": 380
};
const freqs = {
    "A1": 55.00, "B1": 61.74, "C2": 65.41, "D2": 73.42, "E2": 82.41, "F2": 87.31, "G2": 98.00,
    "A2": 110.00, "B2": 123.47, "C3": 130.81, "D3": 146.83, "E3": 164.81, "F3": 174.61, "G3": 196.00,
    "A3": 220.00, "B3": 246.94, "C4": 261.63, "D4": 293.66, "E4": 329.63, "F4": 349.23, "G4": 392.00,
    "A4": 440.00, "B4": 493.88, "C5": 523.25, "D5": 587.33, "E5": 659.25,
    "F5": 698.46, "G5": 783.99, "A5": 880.00, "B5": 987.77, "C6": 1046.50
};
const noteDurations = {
    "semibreve": 2.0, "minima": 1.0, "seminima": 0.5, "colcheia": 0.25, "semicolcheia": 0.125,
    "pausa-semibreve": 2.0, "pausa-minima": 1.0, "pausa-seminima": 0.5, 
    "pausa-colcheia": 0.25, "pausa-semicolcheia": 0.125
};
const SHARP_FACTOR = 1.059463;
const FLAT_FACTOR = 1 / SHARP_FACTOR;

// Escalas musicais (semitons relativos a C)
const scales = {
    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    major: [0, 2, 4, 5, 7, 9, 11],
    minor: [0, 2, 3, 5, 7, 8, 10],
    pentatonic: [0, 2, 4, 7, 9]
};
function checkAndCreateNewStaff() {
    const currentGrandStaff = staffs[currentStaffIndex];
    const trebleCount = currentGrandStaff[0].notes.length;
    const bassCount = currentGrandStaff[1].notes.length;
    const maxCount = Math.max(trebleCount, bassCount);
    if (maxCount >= MAX_NOTES_PER_STAFF) {
        staffs.push([{ clef: 'treble', notes: [] }, { clef: 'bass', notes: [] }]);
        currentStaffIndex = staffs.length - 1;
        updateStaffIndicator();
        return true;
    }
    return false;
}
function updateStaffIndicator() {
    const indicator = document.getElementById('staff-indicator');
    if (indicator) {
        indicator.textContent = `Pauta ${currentStaffIndex + 1}/${staffs.length}`;
    }
}

// Converte tempo em segundos para tipo de nota musical com l√≥gica matem√°tica
function calculateNoteType(seconds, bpm = 30) {
    // BPM = batidas por minuto
    // Uma batida = 60/BPM segundos para colcheia (quarter note)
    const quarterNoteDuration = 60 / bpm; // dura√ß√£o de uma colcheia em segundos

    // Calcular quantas colcheias cabem no tempo
    const quarterNotes = seconds / quarterNoteDuration;

    // L√≥gica matem√°tica: usar pot√™ncias de 2 para dura√ß√µes
    // minima (4 colcheias), seminima (2 colcheias), colcheia (1 colcheia)
    if (quarterNotes >= 3.5) return 'minima';      // >= 3.5 colcheias = minima
    if (quarterNotes >= 1.5) return 'seminima';    // >= 1.5 colcheias = seminima
    return 'colcheia';                             // < 1.5 colcheias = colcheia
}

function hideError() {
    const errorMessage = document.getElementById('errorMessage');
    errorMessage.style.display = 'none';
}

function showError(message) {
    const errorMessage = document.getElementById('errorMessage');
    errorMessage.textContent = '‚ùå ' + message;
    errorMessage.style.display = 'block';

    // Sugest√µes baseadas no erro
    if (message.includes('n√£o suportado')) {
        errorMessage.innerHTML += '<br><br><strong>Solu√ß√£o:</strong> Converta o arquivo para WAV ou MP3 usando um app como:<br>‚Ä¢ <a href="https://online-audio-converter.com" target="_blank" style="color: #c53030;">Online Audio Converter</a><br>‚Ä¢ Media Converter (Android)<br>‚Ä¢ The Audio Converter (iOS)';
    }
}

function showAudioInfo(buffer, file) {
    const audioInfo = document.getElementById('audioInfo');
    const duration = buffer.duration.toFixed(1);
    const sampleRate = buffer.sampleRate;
    const channels = buffer.numberOfChannels;
    const fileSize = (file.size / 1024 / 1024).toFixed(2);

    audioInfo.innerHTML = `
        <strong>Informa√ß√µes do √°udio:</strong><br>
        Dura√ß√£o: ${duration}s | Taxa: ${sampleRate}Hz | Canais: ${channels} | Tamanho: ${fileSize}MB
    `;
    audioInfo.style.display = 'block';
}

function getNoteName(freq) {
    const A4 = 440;
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    const halfSteps = 12 * Math.log2(freq / A4) + 69; // 69 semitons = A4 (correto)
    const octave = Math.floor(halfSteps / 12);
    const note = Math.round(halfSteps % 12);

    return noteNames[note] + octave;
}

function closestNoteInScale(freq, scale) {
    const A4 = 440;
    const C0 = A4 * Math.pow(2, -4.75); // C0 frequency

    // Converter frequ√™ncia para semitons de C0
    const halfSteps = 12 * Math.log2(freq / C0);
    const octave = Math.floor(halfSteps / 12);
    const noteInOctave = Math.round(halfSteps % 12);

    // Encontrar nota mais pr√≥xima na escala
    let closest = scale[0];
    let minDist = Math.abs(noteInOctave - scale[0]);

    for (let note of scale) {
        const dist = Math.abs(noteInOctave - note);
        if (dist < minDist) {
            minDist = dist;
            closest = note;
        }
    }

    // Converter de volta para frequ√™ncia
    const targetHalfSteps = octave * 12 + closest;
    return C0 * Math.pow(2, targetHalfSteps / 12);
}

function phaseVocoder(buffer, ratio, fftSize) {
    // Implementa√ß√£o simplificada de phase vocoder
    // Para produ√ß√£o seria ideal usar FFT, mas aqui uso interpola√ß√£o de alta qualidade
    const output = new Float32Array(buffer.length);

    for (let i = 0; i < output.length; i++) {
        const sourcePos = i / ratio;

        // Interpola√ß√£o c√∫bica (melhor que linear)
        const i0 = Math.floor(sourcePos) - 1;
        const i1 = Math.floor(sourcePos);
        const i2 = Math.floor(sourcePos) + 1;
        const i3 = Math.floor(sourcePos) + 2;
        const frac = sourcePos - Math.floor(sourcePos);

        // Garantir limites
        const s0 = (i0 >= 0 && i0 < buffer.length) ? buffer[i0] : 0;
        const s1 = (i1 >= 0 && i1 < buffer.length) ? buffer[i1] : 0;
        const s2 = (i2 >= 0 && i2 < buffer.length) ? buffer[i2] : 0;
        const s3 = (i3 >= 0 && i3 < buffer.length) ? buffer[i3] : 0;

        // Interpola√ß√£o c√∫bica de Catmull-Rom
        const a0 = -0.5 * s0 + 1.5 * s1 - 1.5 * s2 + 0.5 * s3;
        const a1 = s0 - 2.5 * s1 + 2 * s2 - 0.5 * s3;
        const a2 = -0.5 * s0 + 0.5 * s2;
        const a3 = s1;

        output[i] = a0 * frac * frac * frac + a1 * frac * frac + a2 * frac + a3;
    }

    return output;
}

function detectPitch(buffer, sampleRate) {
    const SIZE = buffer.length;
    let rms = 0;

    // Calcular RMS
    for (let i = 0; i < SIZE; i++) {
        rms += buffer[i] * buffer[i];
    }
    rms = Math.sqrt(rms / SIZE);

    if (rms < 0.005) return -1; // Sil√™ncio

    // Autocorrela√ß√£o usando YIN algorithm (mais preciso)
    const threshold = 0.1;
    const minLag = Math.floor(sampleRate / 1000); // 1000 Hz max
    const maxLag = Math.floor(sampleRate / 80);   // 80 Hz min

    // Difference function
    const diff = new Float32Array(maxLag);
    for (let lag = 0; lag < maxLag; lag++) {
        let sum = 0;
        for (let i = 0; i < SIZE - maxLag; i++) {
            const delta = buffer[i] - buffer[i + lag];
            sum += delta * delta;
        }
        diff[lag] = sum;
    }

    // Cumulative mean normalized difference
    const cmndf = new Float32Array(maxLag);
    cmndf[0] = 1;
    let runningSum = 0;

    for (let lag = 1; lag < maxLag; lag++) {
        runningSum += diff[lag];
        cmndf[lag] = diff[lag] / (runningSum / lag);
    }

    // Find first minimum below threshold
    let bestLag = -1;
    for (let lag = minLag; lag < maxLag; lag++) {
        if (cmndf[lag] < threshold) {
            // Parabolic interpolation for sub-sample accuracy
            if (lag > 0 && lag < maxLag - 1) {
                const s0 = cmndf[lag - 1];
                const s1 = cmndf[lag];
                const s2 = cmndf[lag + 1];
                const adjustment = (s2 - s0) / (2 * (2 * s1 - s2 - s0));
                bestLag = lag + adjustment;
            } else {
                bestLag = lag;
            }
            break;
        }
    }

    if (bestLag > 0) {
        const pitch = sampleRate / bestLag;
        if (pitch >= 80 && pitch <= 1000) {
            return pitch;
        }
    }

    return -1;
}

function updateProgress(percent, text) {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    progressFill.style.width = percent + '%';
    if (text) progressText.textContent = text;
}

function bufferToWave(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;

    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;

    const data = [];
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
            let sample = buffer.getChannelData(ch)[i];
            sample = Math.max(-1, Math.min(1, sample));
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            data.push(sample);
        }
    }

    const dataSize = data.length * bytesPerSample;
    const view = new DataView(new ArrayBuffer(44 + dataSize));

    // RIFF header
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');

    // fmt chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);

    // data chunk
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i = 0; i < data.length; i++) {
        view.setInt16(offset, data[i], true);
        offset += 2;
    }

    return view.buffer;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

async function handleFileSelect() {
    const fileInput = document.getElementById('audioFile');
    const uploadArea = document.getElementById('uploadArea');
    const processBtn = document.getElementById('processBtn');
    const file = fileInput.files[0];
    if (!file) return;

    hideError();
    document.getElementById('audioInfo').style.display = 'none';
    uploadArea.classList.remove('has-file', 'error');
    processBtn.disabled = true;

    // Mostrar que est√° carregando
    uploadArea.querySelector('p').innerHTML = `<strong>‚è≥ Carregando ${file.name}...</strong>`;

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Tentar carregar o √°udio
        const arrayBuffer = await file.arrayBuffer();

        // Tentar decodificar
        try {
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // Sucesso!
            uploadArea.classList.add('has-file');
            uploadArea.querySelector('p').innerHTML = `<strong>‚úì ${file.name}</strong><br><span style="font-size: 12px;">Pronto para processar</span>`;
            processBtn.disabled = false;

            // Mostrar informa√ß√µes do √°udio
            showAudioInfo(audioBuffer, file);

        } catch (decodeError) {
            // Erro ao decodificar - formato n√£o suportado
            throw new Error('Formato de √°udio n√£o suportado pelo navegador. Use WAV ou MP3 de alta qualidade.');
        }

    } catch (error) {
        uploadArea.classList.add('error');
        uploadArea.querySelector('p').innerHTML = `<strong>‚ùå Erro ao carregar</strong>`;
        showError(error.message);
    }
}

async function autotune(buffer, sampleRate, strength, scale) {
    const windowSize = 4096; // Janela maior = melhor detec√ß√£o
    const hopSize = 1024;
    const output = new Float32Array(buffer.length);
    const overlapAdd = new Float32Array(buffer.length); // Para contagem de sobreposi√ß√£o

    // Para tracking de pitch m√©dio
    let pitchSum = 0;
    let pitchCount = 0;
    let lastDisplayedPitch = 0;

    // Para coleta de dados de frequ√™ncia
    lastNoteStartTime = 0;

    // Processar em janelas com yield para n√£o travar
    const totalWindows = Math.floor((buffer.length - windowSize) / hopSize);
    let windowCount = 0;

    for (let i = 0; i < buffer.length - windowSize; i += hopSize) {
        // Criar janela
        const window = new Float32Array(windowSize);
        for (let j = 0; j < windowSize; j++) {
            window[j] = buffer[i + j];
        }

        // Detectar pitch
        const pitch = detectPitch(window, sampleRate);

        if (pitch > 0) {
            // Acumular para estat√≠sticas
            pitchSum += pitch;
            pitchCount++;

            // Encontrar nota mais pr√≥xima na escala
            const targetPitch = closestNoteInScale(pitch, scale);
            const noteName = getNoteName(targetPitch);

            // Coletar dados musicais - detectar mudan√ßa de nota com buffer para evitar notas fantasma
            const currentTime = (i / sampleRate);

            // Adicionar ao buffer de mudan√ßa de nota
            noteChangeBuffer.push({
                pitch: noteName,
                time: currentTime,
                frequency: targetPitch
            });

            // Manter apenas √∫ltimas 5 detec√ß√µes no buffer
            if (noteChangeBuffer.length > 5) {
                noteChangeBuffer.shift();
            }

            // Verificar se h√° mudan√ßa consistente de nota (pelo menos 3 das √∫ltimas 5 detec√ß√µes)
            let noteChanged = false;
            if (noteChangeBuffer.length >= 3) {
                const recentPitches = noteChangeBuffer.slice(-3);
                const majorityPitch = recentPitches[0].pitch;
                const consistentCount = recentPitches.filter(n => n.pitch === majorityPitch).length;

                // Se 3 das √∫ltimas 3 detec√ß√µes s√£o consistentes e diferentes da atual
                if (consistentCount >= 3 && currentNoteData && currentNoteData.pitch !== majorityPitch) {
                    noteChanged = true;
                    lastStablePitch = majorityPitch;
                }
            }

            if (currentNoteData === null) {
                // Primeira nota
                currentNoteData = {
                    pitch: noteName,
                    startTime: currentTime,
                    sampleCount: 1
                };
                lastStablePitch = noteName;
            } else if (noteChanged && lastStablePitch !== currentNoteData.pitch) {
                // Nota mudou consistentemente - salvar a anterior e come√ßar nova
                const duration = currentTime - currentNoteData.startTime;
                const noteType = calculateNoteType(duration, 30); // 30 BPM

                // S√≥ adicionar se a dura√ß√£o for significativa (> 50ms)
                if (duration > 0.05) {
                    musicalNotes.push({
                        pitch: currentNoteData.pitch,
                        type: noteType,
                        dot: false,
                        accidental: null
                    });
                }

                // Come√ßar nova nota
                currentNoteData = {
                    pitch: lastStablePitch,
                    startTime: currentTime,
                    sampleCount: 1
                };

                // Limpar buffer ap√≥s mudan√ßa confirmada
                noteChangeBuffer = [];
            } else {
                // Mesma nota - incrementar contador
                currentNoteData.sampleCount++;
            }

            // Calcular corre√ß√£o - aplicar strength como fator de "velocidade"
            const ratio = targetPitch / pitch;
            const finalRatio = 1 + (ratio - 1) * strength;

            // Phase vocoder simplificado para melhor qualidade
            const fftSize = windowSize;
            const shiftedWindow = phaseVocoder(window, finalRatio, fftSize);

            // Aplicar janela de Hann e adicionar
            for (let j = 0; j < shiftedWindow.length && i + j < output.length; j++) {
                const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * j / windowSize));
                output[i + j] += shiftedWindow[j] * hannWindow;
                overlapAdd[i + j] += hannWindow;
            }
        } else {
            // Sem pitch detectado, copiar original com janela
            for (let j = 0; j < windowSize && i + j < output.length; j++) {
                const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * j / windowSize));
                output[i + j] += window[j] * hannWindow;
                overlapAdd[i + j] += hannWindow;
            }
        }

        // Atualizar progresso e dar chance ao navegador respirar
        windowCount++;
        if (windowCount % 50 === 0) {
            updateProgress((windowCount / totalWindows) * 100);
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Finalizar a √∫ltima nota se existir (apenas se dura√ß√£o significativa)
    if (currentNoteData !== null) {
        const finalTime = buffer.length / sampleRate;
        const duration = finalTime - currentNoteData.startTime;

        // S√≥ adicionar se a dura√ß√£o for significativa (> 50ms)
        if (duration > 0.05) {
            const noteType = calculateNoteType(duration, 30);
            musicalNotes.push({
                pitch: currentNoteData.pitch,
                type: noteType,
                dot: false,
                accidental: null
            });
        }
    }

    // Normalizar pela sobreposi√ß√£o
    for (let i = 0; i < output.length; i++) {
        if (overlapAdd[i] > 0) {
            output[i] /= overlapAdd[i];
        }
    }

    // Normalizar amplitude
    let max = 0;
    for (let i = 0; i < output.length; i++) {
        const abs = Math.abs(output[i]);
        if (abs > max) max = abs;
    }

    if (max > 0) {
        const normFactor = 0.95 / max; // Deixa margem para evitar clipping
        for (let i = 0; i < output.length; i++) {
            output[i] *= normFactor;
        }
    }

    return output;
}

async function processAudio() {
    if (!audioBuffer) return;

    const processBtn = document.getElementById('processBtn');
    const progress = document.getElementById('progress');

    processBtn.disabled = true;
    progress.style.display = 'block';
    musicalNotes = []; // Limpar dados anteriores
    currentNoteData = null; // Limpar dados da nota atual
    lastNoteStartTime = 0; // Resetar tempo inicial
    hideError();

    const strengthSlider = document.getElementById('strength');
    const scaleSelect = document.getElementById('scale');

    const strength = strengthSlider.value / 100;
    const selectedScale = scales[scaleSelect.value];

    try {
        // Processar cada canal
        const channels = [];
        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
            updateProgress(0, `Processando canal ${ch + 1}/${audioBuffer.numberOfChannels}...`);
            const channelData = audioBuffer.getChannelData(ch);
            const processed = await autotune(channelData, audioBuffer.sampleRate, strength, selectedScale);
            channels.push(processed);
        }

        // Criar buffer de sa√≠da
        processedBuffer = audioContext.createBuffer(
            channels.length,
            channels[0].length,
            audioBuffer.sampleRate
        );

        channels.forEach((channel, i) => {
            processedBuffer.copyToChannel(channel, i);
        });

        updateProgress(100, 'Processamento conclu√≠do! Importando notas para a partitura...');
        setTimeout(() => {
            progress.style.display = 'none';
            // Importar as notas detectadas para a partitura
            importMusicalNotesToScore();
            processBtn.disabled = false;
        }, 1000);

    } catch (error) {
        showError('Erro ao processar: ' + error.message);
        progress.style.display = 'none';
        processBtn.disabled = false;
    }
}

function importMusicalNotesToScore() {
    if (musicalNotes.length === 0) {
        showError('Nenhuma nota musical foi detectada no √°udio.');
        return;
    }

    // Limpar partitura atual
    staffs = [[{ clef: 'treble', notes: [] }, { clef: 'bass', notes: [] }]];
    currentStaffIndex = 0;

    // Organizar notas sequencialmente na clave de Sol (treble)
    const trebleStaff = staffs[0][0]; // Clave de Sol

    // Converter cada nota detectada para o formato da partitura
    musicalNotes.forEach(note => {
        // Converter nome da nota para o formato usado na partitura
        const convertedNote = convertNoteForScore(note);
        trebleStaff.notes.push([convertedNote]);
    });

    // Redesenhar a partitura
    redraw();

    // Mostrar mensagem de sucesso
    const successMessage = document.createElement('div');
    successMessage.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #48bb78;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 1000;
        font-weight: bold;
    `;
    successMessage.textContent = `‚úì ${musicalNotes.length} notas importadas para a partitura!`;
    document.body.appendChild(successMessage);

    setTimeout(() => {
        document.body.removeChild(successMessage);
    }, 3000);
}

function convertNoteForScore(note) {
    // Converte uma nota do formato autotune para o formato da partitura
    // Exemplo: "C4" -> "C4", "C#4" -> "C4" com accidental, etc.

    const pitch = note.pitch;
    let convertedPitch = pitch;
    let accidental = null;

    // Verificar se h√° acidente na nota (sustenido ou bemol)
    if (pitch.includes('#')) {
        convertedPitch = pitch.replace('#', '');
        accidental = 'sharp';
    } else if (pitch.includes('b') || pitch.includes('‚ô≠')) {
        convertedPitch = pitch.replace('b', '').replace('‚ô≠', '');
        accidental = 'flat';
    }

    return {
        pitch: convertedPitch,
        type: note.type,
        dot: note.dot || false,
        accidental: accidental
    };
}

function getDurationInBeats(noteType, dot, bottomNumber) {
    const baseDurations = {
        "semibreve": 4, "minima": 2, "seminima": 1, "colcheia": 0.5, "semicolcheia": 0.25,
        "pausa-semibreve": 4, "pausa-minima": 2, "pausa-seminima": 1, 
        "pausa-colcheia": 0.5, "pausa-semicolcheia": 0.25
    };
    let duration = baseDurations[noteType] || 1;
    if (bottomNumber === 8) duration *= 0.5;
    else if (bottomNumber === 2) duration *= 2;
    if (dot) duration *= 1.5;
    return duration;
}
function drawAccidental(acc, x, y) {
    ctx.font = "24px Arial";
    ctx.fillStyle = "#333";
    const symbol = acc === 'sharp' ? '‚ôØ' : acc === 'flat' ? '‚ô≠' : '‚ôÆ';
    ctx.fillText(symbol, x - 20, y + 8);
}
function drawDot(x, y) {
    ctx.beginPath();
    ctx.arc(x + 18, y, 3, 0, Math.PI * 2);
    ctx.fillStyle = "#333";
    ctx.fill();
}
function drawSemibreve(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawMinima(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawSeminima(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawColcheia(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 10, y - 40);
    ctx.quadraticCurveTo(x + 26, y - 33, x + 10, y - 20);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawSemicolcheia(x, y, dot = false) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.ellipse(x, y, 10, 7, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 10, y);
    ctx.lineTo(x + 10, y - 40);
    ctx.stroke();
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 10, y - 40);
    ctx.quadraticCurveTo(x + 26, y - 33, x + 10, y - 20);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + 10, y - 35);
    ctx.quadraticCurveTo(x + 26, y - 28, x + 10, y - 15);
    ctx.stroke();
    if (dot) drawDot(x, y);
}
function drawRest(type, x, y) {
    ctx.font = "32px Arial";
    ctx.fillStyle = "#333";
    ctx.textAlign = "center";
    const symbols = {
        'pausa-semibreve': ['ùÑª', 110],
        'pausa-minima': ['ùÑº', 130],
        'pausa-seminima': ['ùÑΩ', 120],
        'pausa-colcheia': ['ùÑæ', 120],
        'pausa-semicolcheia': ['ùÑø', 120]
    };
    const [symbol, yOffset] = symbols[type] || ['', 120];
    ctx.fillText(symbol, x, y - (noteYTreble['G4'] - yOffset));
    ctx.textAlign = "left";
}
function drawNote(note, x, y) {
    if (note.type.startsWith('pausa-')) {
        drawRest(note.type, x, y);
        return;
    }
    const dot = note.dot;
    if (note.type === "semibreve") drawSemibreve(x, y, dot);
    else if (note.type === "minima") drawMinima(x, y, dot);
    else if (note.type === "seminima") drawSeminima(x, y, dot);
    else if (note.type === "colcheia") drawColcheia(x, y, dot);
    else if (note.type === "semicolcheia") drawSemicolcheia(x, y, dot);
}
function drawLedgerLines(x, y, yOffset, clef) {
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1.5;
    if (clef === 'treble') {
        const topStaffLine = 80 + yOffset;
        if (y < topStaffLine) {
            for (let lineY = topStaffLine - 20; lineY >= y - 5; lineY -= 20) {
                ctx.beginPath();
                ctx.moveTo(x - 15, lineY);
                ctx.lineTo(x + 15, lineY);
                ctx.stroke();
            }
        }
        const bottomStaffLine = 160 + yOffset;
        if (y > bottomStaffLine) {
            for (let lineY = bottomStaffLine + 20; lineY <= y + 5; lineY += 20) {
                ctx.beginPath();
                ctx.moveTo(x - 15, lineY);
                ctx.lineTo(x + 15, lineY);
                ctx.stroke();
            }
        }
    } else {
        const topStaffLine = 260 + yOffset;
        if (y < topStaffLine) {
            for (let lineY = topStaffLine - 20; lineY >= y - 5; lineY -= 20) {
                ctx.beginPath();
                ctx.moveTo(x - 15, lineY);
                ctx.lineTo(x + 15, lineY);
                ctx.stroke();
            }
        }
        const bottomStaffLine = 340 + yOffset;
        if (y > bottomStaffLine) {
            for (let lineY = bottomStaffLine + 20; lineY <= y + 5; lineY += 20) {
                ctx.beginPath();
                ctx.moveTo(x - 15, lineY);
                ctx.lineTo(x + 15, lineY);
                ctx.stroke();
            }
        }
    }
}
function drawBarline(x, yOffset) {
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, 80 + yOffset);
    ctx.lineTo(x, 160 + yOffset);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, 260 + yOffset);
    ctx.lineTo(x, 340 + yOffset);
    ctx.stroke();
}
function drawKeySharps(yBase, clef) {
    const positions = clef === 'treble' ? 
        ['F5', 'C5', 'G5', 'D5', 'A4', 'E5', 'B4'] :
        ['A3', 'E3', 'B2', 'F3', 'C3', 'G3', 'D3'];
    const noteYMap = clef === 'treble' ? noteYTreble : noteYBass;
	const yOffsetFino = clef === 'treble' ? 10 : 170;
    for (let i = 0; i < keySharps; i++) {
        const pitch = positions[i];
        const x = 80 + (i * 12);
        const y = noteYMap[pitch] + yBase;
        ctx.font = "24px Arial";
        ctx.fillStyle = "#333";
        ctx.fillText("‚ôØ", x, y - yOffsetFino);
    }
}
function drawKeyFlats(yBase, clef) {
    const positions = clef === 'treble' ?
        ['B4', 'E5', 'A4', 'D5', 'G4', 'C5', 'F4'] :
        ['D3', 'G3', 'C3', 'F3', 'B2', 'E3', 'A2'];
    const noteYMap = clef === 'treble' ? noteYTreble : noteYBass;
	const yOffsetFino = clef === 'treble' ? 10 : 170;
    for (let i = 0; i < keyFlats; i++) {
        const pitch = positions[i];
        const x = 80 + (i * 12);
        const y = noteYMap[pitch] + yBase;
        ctx.font = "24px Arial";
        ctx.fillStyle = "#333";
        ctx.fillText("‚ô≠", x, y - yOffsetFino);
    }
}
function drawTimeSignature(x, yBase) {
    ctx.font = "bold 28px Georgia, serif";
    ctx.fillStyle = "#333";
    ctx.textAlign = "center";
    const centerY = yBase + 100;
    ctx.fillText(timeSignature.top.toString(), x, centerY - 12);
    ctx.fillText(timeSignature.bottom.toString(), x, centerY + 22);
    ctx.textAlign = "left";
}
function drawSingleStaff(yBase, clef, isActive = false) {
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 5; i++) {
        const y = yBase + 80 + i * 20;
        ctx.beginPath();
        ctx.moveTo(20, y);
        ctx.lineTo(canvas.width - 20, y);
        ctx.stroke();
    }
    if (isActive) {
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
        ctx.lineWidth = 3;
        ctx.strokeRect(15, yBase + 75, canvas.width - 35, 90);
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1.5;
    }
    if (clef === 'treble') {
        ctx.font = "70px 'Segoe UI Symbol', 'Noto Sans Symbols', Arial, sans-serif"; 
        ctx.fillStyle = "#333";
        ctx.textBaseline = "top";
        ctx.fillText("ùÑû", 35, yBase + 78);
    } else {
        ctx.font = "50px 'Segoe UI Symbol', 'Noto Sans Symbols', Arial, sans-serif";
        ctx.fillStyle = "#333";
        ctx.textBaseline = "top";
        ctx.fillText("ùÑ¢", 35, yBase + 78);
    }
    if (keySharps > 0) drawKeySharps(yBase, clef);
    else if (keyFlats > 0) drawKeyFlats(yBase, clef);
    drawTimeSignature(110, yBase);
    ctx.beginPath();
    ctx.moveTo(canvas.width - 20, yBase + 80);
    ctx.lineTo(canvas.width - 20, yBase + 160);
    ctx.stroke();
}
function drawStaff(staffIndex) {
    const yOffset = staffIndex * STAFF_OFFSET;
    const isActive = staffIndex === currentStaffIndex;
    drawSingleStaff(yOffset, 'treble', isActive && currentClef === 'treble');
    drawSingleStaff(yOffset + 180, 'bass', isActive && currentClef === 'bass');
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(15, 80 + yOffset);
    ctx.lineTo(15, 340 + yOffset);
    ctx.stroke();
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(20, 80 + yOffset);
    ctx.lineTo(20, 160 + yOffset);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(20, 260 + yOffset);
    ctx.lineTo(20, 340 + yOffset);
    ctx.stroke();
}
function redraw() {
    let maxNotesCount = 0;
    for (const grandStaff of staffs) {
        const trebleCount = grandStaff[0].notes.length;
        const bassCount = grandStaff[1].notes.length;
        const maxCount = Math.max(trebleCount, bassCount);
        if (maxCount > maxNotesCount) maxNotesCount = maxCount;
    }
    let requiredWidth = CLEF_MARGIN + (maxNotesCount * SPACING) + SPACING + 20;
    canvas.width = Math.max(MIN_SCORE_WIDTH, requiredWidth);
    const requiredHeight = staffs.length * STAFF_OFFSET + 100;
    canvas.height = requiredHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = "bold 16px Arial";
    ctx.fillStyle = "#3b82f6";
    ctx.fillText(`üìù Pauta Ativa: ${currentStaffIndex + 1}/${staffs.length} (${currentClef === 'treble' ? 'Sol' : 'F√°'})`, 20, 25);
    staffs.forEach((grandStaff, staffIndex) => {
        drawStaff(staffIndex);
        const yOffsetBase = staffIndex * STAFF_OFFSET;
        let xTreble = CLEF_MARGIN;
        let currentBeat = 0;
        for (const chord of grandStaff[0].notes) {
            for (const note of chord) {
                if (note.type.startsWith('pausa-')) {
                    drawRest(note.type, xTreble, yOffsetBase);
                } else {
                    const noteYPos = noteYTreble[note.pitch] + yOffsetBase;
                    drawLedgerLines(xTreble, noteYPos, yOffsetBase, 'treble');
                    if (note.accidental) drawAccidental(note.accidental, xTreble, noteYPos);
                    drawNote(note, xTreble, noteYPos);
                }
            }
            const noteDuration = getDurationInBeats(chord[0].type, chord[0].dot, timeSignature.bottom);
            currentBeat += noteDuration;
            if (currentBeat >= timeSignature.top) {
                drawBarline(xTreble + SPACING/2, yOffsetBase);
                currentBeat = 0;
            }
            xTreble += SPACING;
        }
        let xBass = CLEF_MARGIN;
        currentBeat = 0;
        for (const chord of grandStaff[1].notes) {
            for (const note of chord) {
                if (note.type.startsWith('pausa-')) {
                    drawRest(note.type, xBass, yOffsetBase + 180);
                } else {
                    const noteYPos = noteYBass[note.pitch] + yOffsetBase;
                    drawLedgerLines(xBass, noteYPos, yOffsetBase, 'bass');
                    if (note.accidental) drawAccidental(note.accidental, xBass, noteYPos);
                    drawNote(note, xBass, noteYPos);
                }
            }
            const noteDuration = getDurationInBeats(chord[0].type, chord[0].dot, timeSignature.bottom);
            currentBeat += noteDuration;
            if (currentBeat >= timeSignature.top) {
                drawBarline(xBass + SPACING/2, yOffsetBase + 180);
                currentBeat = 0;
            }
            xBass += SPACING;
        }
    });
    updateStaffIndicator();
}
let piano = null;
async function initPiano() {
    if (piano) return;
    piano = new Tone.Sampler({
        urls: {
            "C4": "C4.mp3",
            "D#4": "Ds4.mp3",
            "F#4": "Fs4.mp3",
            "A4": "A4.mp3",
        },
        release: 1,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
    }).toDestination();
    await Tone.loaded();
}
function freqToNoteName(freq) {
    const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const A4 = 440;
    const C0 = A4 * Math.pow(2, -4.75);
    let halfSteps = Math.round(12 * Math.log2(freq / C0));
    const octave = Math.floor(halfSteps / 12);
    return notes[halfSteps % 12] + octave;
}
async function playFreq(freq, duration, startTime = 0) {
    await initPiano();
    const note = freqToNoteName(freq);
    piano.triggerAttackRelease(note, duration, Tone.now() + startTime, 0.6);
}
async function playScore() {
    await initPiano();
    await Tone.start();
    let allNotes = [];
    for (const grandStaff of staffs) {
        const trebleNotes = grandStaff[0].notes;
        const bassNotes = grandStaff[1].notes;
        const maxLength = Math.max(trebleNotes.length, bassNotes.length);
        for (let i = 0; i < maxLength; i++) {
            const combined = [];
            if (i < trebleNotes.length) combined.push(...trebleNotes[i]);
            if (i < bassNotes.length) combined.push(...bassNotes[i]);
            allNotes.push(combined);
        }
    }
    if (allNotes.length === 0) {
        alert("Adicione notas primeiro!");
        return;
    }
    let t = 0;
    const beatDuration = 60 / tempo;
    for (const chord of allNotes) {
        if (chord.length === 0) continue;
        const baseNote = chord[0];
        if (baseNote.type.startsWith('pausa-')) {
            let duration = noteDurations[baseNote.type] * beatDuration;
            if (baseNote.dot) duration *= 1.5;
            t += duration;
            continue;
        }
        let duration = noteDurations[baseNote.type] * beatDuration;
        if (baseNote.dot) duration *= 1.5;
        for (const note of chord) {
            if (note.type.startsWith('pausa-')) continue;
            let freq = freqs[note.pitch];

				
			// Aplica acidentes da armadura de clave
			if (!note.accidental) { // S√≥ aplica se a nota n√£o tem acidente pr√≥prio
				const sharpOrder = ['F', 'C', 'G', 'D', 'A', 'E', 'B'];
				const flatOrder = ['B', 'E', 'A', 'D', 'G', 'C', 'F'];
				
				const noteLetter = note.pitch[0]; // Pega s√≥ a letra (C, D, E, etc)
				
				if (keySharps > 0) {
					if (sharpOrder.slice(0, keySharps).includes(noteLetter)) {
						freq *= SHARP_FACTOR;
					}
				} else if (keyFlats > 0) {
					if (flatOrder.slice(0, keyFlats).includes(noteLetter)) {
						freq *= FLAT_FACTOR;
					}
				}
			}

            if (note.accidental === 'sharp') freq *= SHARP_FACTOR;
            else if (note.accidental === 'flat') freq *= FLAT_FACTOR;
            await playFreq(freq, duration, t);
        }
        t += duration;
    }
}
function importFromJSON(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            if (data.version !== "1.0") {
                alert("Vers√£o incompat√≠vel");
                return;
            }
            tempo = data.tempo || 120;
            timeSignature.top = data.timeSignature.top || 4;
            timeSignature.bottom = data.timeSignature.bottom || 4;
            keySharps = data.keySignature.sharps || 0;
            keyFlats = data.keySignature.flats || 0;
            staffs = data.staffs || [[{ clef: 'treble', notes: [] }, { clef: 'bass', notes: [] }]];
            currentStaffIndex = 0;
            document.getElementById('title-input').value = data.title || '';
            document.getElementById('composer-input').value = data.composer || '';
            document.getElementById('tempo-input').value = tempo;
            document.getElementById('time-top').value = timeSignature.top;
            document.getElementById('time-bottom').value = timeSignature.bottom;
            redraw();
            alert("Importado!");
        } catch (error) {
            alert("Erro ao carregar arquivo");
        }
    };
    reader.readAsText(file);
}
function exportToJSON() {
    const data = {
        version: "1.0",
        title: document.getElementById('title-input').value,
        composer: document.getElementById('composer-input').value,
        tempo: tempo,
        timeSignature: timeSignature,
        keySignature: { sharps: keySharps, flats: keyFlats },
        staffs: staffs
    };
    const json = JSON.stringify(data);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${data.title.replace(/\s+/g, '_')}.json`;
    a.click();
    URL.revokeObjectURL(url);
}
function exportToMusicXML() {
    const title = document.getElementById('title-input').value;
    const composer = document.getElementById('composer-input').value;
    let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <work><work-title>${title}</work-title></work>
  <identification><creator type="composer">${composer}</creator></identification>
  <part-list><score-part id="P1"><part-name>Piano</part-name></score-part></part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>4</divisions>
        <key><fifths>${keySharps - keyFlats}</fifths></key>
        <time><beats>${timeSignature.top}</beats><beat-type>${timeSignature.bottom}</beat-type></time>
        <clef><sign>G</sign><line>2</line></clef>
      </attributes>
    </measure>
  </part>
</score-partwise>`;
    const blob = new Blob([xml], { type: 'application/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title.replace(/\s+/g, '_')}.musicxml`;
    a.click();
    URL.revokeObjectURL(url);
}
function exportToPDF() {
    const title = document.getElementById('title-input').value;
    const composer = document.getElementById('composer-input').value;
    const pdfCanvas = document.createElement('canvas');
    pdfCanvas.width = canvas.width;
    pdfCanvas.height = canvas.height + 100;
    const pdfCtx = pdfCanvas.getContext('2d');
    pdfCtx.fillStyle = 'white';
    pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    pdfCtx.fillStyle = 'black';
    pdfCtx.font = 'bold 24px Arial';
    pdfCtx.textAlign = 'center';
    pdfCtx.fillText(title, pdfCanvas.width / 2, 40);
    if (composer) {
        pdfCtx.font = '16px Arial';
        pdfCtx.fillText(composer, pdfCanvas.width / 2, 70);
    }
    pdfCtx.drawImage(canvas, 0, 100);
    pdfCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${title.replace(/\s+/g, '_')}.png`;
        a.click();
        URL.revokeObjectURL(url);
    });
}
redraw();

// Event listeners para upload de √°udio
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('audioFile');
const processBtn = document.getElementById('processBtn');
const strengthSlider = document.getElementById('strength');
const strengthValue = document.getElementById('strengthValue');

uploadArea.addEventListener('click', () => fileInput.click());

uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.style.background = '#f0f4ff';
});

uploadArea.addEventListener('dragleave', () => {
    uploadArea.style.background = '';
});

uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.style.background = '';
    if (e.dataTransfer.files.length) {
        fileInput.files = e.dataTransfer.files;
        handleFileSelect();
    }
});

fileInput.addEventListener('change', handleFileSelect);

strengthSlider.addEventListener('input', (e) => {
    strengthValue.textContent = e.target.value + '%';
});

processBtn.addEventListener('click', processAudio);

document.getElementById('time-top').addEventListener('change', (e) => {
    timeSignature.top = parseInt(e.target.value);
    redraw();
});
document.getElementById('time-bottom').addEventListener('change', (e) => {
    timeSignature.bottom = parseInt(e.target.value);
    redraw();
});
document.getElementById('tempo-input').addEventListener('change', (e) => {
    tempo = parseInt(e.target.value);
});
document.querySelectorAll('.fig-button').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.fig-button').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedType = btn.dataset.type;
        useDot = btn.dataset.dot === 'true';
        isHarmonyMode = false;
        document.getElementById('harmony-btn').classList.remove('active');
    });
});
document.querySelectorAll('.accidental-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const accType = btn.dataset.accidental;
        if (selectedAccidental === accType) {
            selectedAccidental = null;
            btn.classList.remove('selected');
        } else {
            document.querySelectorAll('.accidental-btn').forEach(b => b.classList.remove('selected'));
            selectedAccidental = accType;
            btn.classList.add('selected');
        }
    });
});
document.getElementById('key-sharp-up').addEventListener('click', () => {
    if (keyFlats > 0) {
        alert('Remova os bem√≥is antes');
        return;
    }
    if (keySharps < 7) {
        keySharps++;
        redraw();
    }
});
document.getElementById('key-sharp-down').addEventListener('click', () => {
    if (keySharps > 0) {
        keySharps--;
        redraw();
    }
});
document.getElementById('key-flat-up').addEventListener('click', () => {
    if (keySharps > 0) {
        alert('Remova os sustenidos antes');
        return;
    }
    if (keyFlats < 7) {
        keyFlats++;
        redraw();
    }
});
document.getElementById('key-flat-down').addEventListener('click', () => {
    if (keyFlats > 0) {
        keyFlats--;
        redraw();
    }
});
document.getElementById('key-reset').addEventListener('click', () => {
    keySharps = 0;
    keyFlats = 0;
    redraw();
});
document.getElementById('harmony-btn').addEventListener('click', () => {
    isHarmonyMode = !isHarmonyMode;
    document.getElementById('harmony-btn').classList.toggle('active');
});
document.getElementById('clef-treble-btn').addEventListener('click', () => {
    currentClef = 'treble';
    document.getElementById('clef-treble-btn').classList.add('active');
    document.getElementById('clef-bass-btn').classList.remove('active');
    redraw();
});
document.getElementById('clef-bass-btn').addEventListener('click', () => {
    currentClef = 'bass';
    document.getElementById('clef-bass-btn').classList.add('active');
    document.getElementById('clef-treble-btn').classList.remove('active');
    redraw();
});
document.getElementById('add-staff-btn').addEventListener('click', () => {
    staffs.push([{ clef: 'treble', notes: [] }, { clef: 'bass', notes: [] }]);
    currentStaffIndex = staffs.length - 1;
    redraw();
});
document.getElementById('play-btn').addEventListener('click', playScore);
document.getElementById('undo-btn').addEventListener('click', () => {
    const grandStaff = staffs[currentStaffIndex];
    const clefIndex = currentClef === 'treble' ? 0 : 1;
    const targetStaff = grandStaff[clefIndex].notes;
    if (targetStaff.length > 0) {
        const lastChord = targetStaff[targetStaff.length - 1];
        if (lastChord.length > 1) lastChord.pop();
        else targetStaff.pop();
        redraw();
    }
});
document.getElementById('clear-btn').addEventListener('click', () => {
    let hasNotes = false;
    for (const grandStaff of staffs) {
        if (grandStaff[0].notes.length > 0 || grandStaff[1].notes.length > 0) {
            hasNotes = true;
            break;
        }
    }
    if (hasNotes && confirm("Limpar tudo?")) {
        staffs = [[{ clef: 'treble', notes: [] }, { clef: 'bass', notes: [] }]];
        currentStaffIndex = 0;
        keySharps = 0;
        keyFlats = 0;
        redraw();
    }
});
document.getElementById('download-btn').addEventListener('click', () => {
    document.getElementById('export-modal').classList.add('active');
});
document.getElementById('export-json').addEventListener('click', () => {
    exportToJSON();
    document.getElementById('export-modal').classList.remove('active');
});
document.getElementById('import-file').addEventListener('change', importFromJSON);
document.getElementById('export-musicxml').addEventListener('click', () => {
    exportToMusicXML();
    document.getElementById('export-modal').classList.remove('active');
});
document.getElementById('export-pdf').addEventListener('click', () => {
    exportToPDF();
    document.getElementById('export-modal').classList.remove('active');
});
document.getElementById('export-cancel').addEventListener('click', () => {
    document.getElementById('export-modal').classList.remove('active');
});
canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clickX = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;
    let targetStaffIndex = Math.floor(clickY / STAFF_OFFSET);
    if (targetStaffIndex >= staffs.length) targetStaffIndex = staffs.length - 1;
    if (targetStaffIndex < 0) targetStaffIndex = 0;
    currentStaffIndex = targetStaffIndex;
    const staffYOffset = targetStaffIndex * STAFF_OFFSET;
    const relativeY = clickY - staffYOffset;
    if (relativeY > 200 && relativeY < 380) {
        currentClef = 'bass';
        document.getElementById('clef-bass-btn').classList.add('active');
        document.getElementById('clef-treble-btn').classList.remove('active');
    } else if (relativeY >= 50 && relativeY <= 200) {
        currentClef = 'treble';
        document.getElementById('clef-treble-btn').classList.add('active');
        document.getElementById('clef-bass-btn').classList.remove('active');
    } else {
        return;
    }
    if (selectedType.startsWith('pausa-')) {
        const newNote = {
            type: selectedType,
            dot: useDot,
            pitch: null,
            accidental: null
        };
        const clefIndex = currentClef === 'treble' ? 0 : 1;
        const targetStaff = staffs[currentStaffIndex][clefIndex].notes;
        if (isHarmonyMode && targetStaff.length > 0) {
            alert('Pausas n√£o podem ser adicionadas em harmonia');
            return;
        }
        targetStaff.push([newNote]);
        checkAndCreateNewStaff();
        redraw();
        return;
    }
    const noteYMap = currentClef === 'treble' ? noteYTreble : noteYBass;
    let bestPitch = null;
    let bestDist = Infinity;
    for (const p in noteYMap) {
        const noteAbsoluteY = noteYMap[p] + staffYOffset;
        const d = Math.abs(noteAbsoluteY - clickY);
        if (d < bestDist) {
            bestDist = d;
            bestPitch = p;
        }
    }
	
	
	// --- LOG DE DEBUG PARA ALINHAMENTO ---
console.log(`--- CLIQUE NA PAUTA ${currentStaffIndex} (${currentClef.toUpperCase()}) ---`);
console.log(`Y do Clique: ${clickY.toFixed(2)} | Y Relativo √† Pauta: ${relativeY.toFixed(2)}`);
console.log(`Nota Identificada: ${bestPitch} | Dist√¢ncia do centro: ${bestDist.toFixed(2)}px`);

// Se a dist√¢ncia for grande, o mapa est√° longe do clique
if (bestDist > 10) {
    console.warn(`Aviso: O clique em ${clickY.toFixed(2)} est√° longe da nota ${bestPitch} (esperado: ${noteYMap[bestPitch] + staffYOffset})`);
}

// Verifica se o mapa de notas existe para essa clave
if (Object.keys(noteYMap).length === 0) {
    console.error(`Erro: O mapa noteY${currentClef.charAt(0).toUpperCase() + currentClef.slice(1)} est√° vazio!`);
}
	
	

    if (bestDist > 25) return;
    const newNote = {
        pitch: bestPitch,
        type: selectedType,
        dot: useDot,
        accidental: selectedAccidental
    };
    const clefIndex = currentClef === 'treble' ? 0 : 1;
    const targetStaff = staffs[currentStaffIndex][clefIndex].notes;
    if (isHarmonyMode && targetStaff.length > 0) {
        const lastChord = targetStaff[targetStaff.length - 1];
        const isPitchPresent = lastChord.some(note =>
            note.pitch === bestPitch && note.accidental === selectedAccidental
        );
        if (!isPitchPresent) lastChord.push(newNote);
    } else {
        targetStaff.push([newNote]);
    }
    selectedAccidental = null;
    document.querySelectorAll('.accidental-btn').forEach(b => b.classList.remove('selected'));
    checkAndCreateNewStaff();
    redraw();
});
document.getElementById('export-modal').addEventListener('click', (e) => {
    if (e.target.id === 'export-modal') {
        e.target.classList.remove('active');
    }
});
document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowUp') {
        e.preventDefault();
        if (currentStaffIndex > 0) {
            currentStaffIndex--;
            redraw();
        }
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowDown') {
        e.preventDefault();
        if (currentStaffIndex < staffs.length - 1) {
            currentStaffIndex++;
            redraw();
        }
    }
});
</script>    
</body>
</html>
